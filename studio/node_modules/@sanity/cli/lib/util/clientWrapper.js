"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clientWrapper;

var _client = _interopRequireDefault(require("@sanity/client"));

var _getUserConfig = _interopRequireDefault(require("./getUserConfig"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-process-env */
const envAuthToken = process.env.SANITY_AUTH_TOKEN;
const sanityEnv = process.env.SANITY_ENV || 'production';
/* eslint-enable no-process-env */

const apiHosts = {
  staging: 'https://api.sanity.work',
  development: 'http://api.sanity.wtf'
  /**
   * Creates a wrapper/getter function to retrieve a Sanity API client.
   * Instead of spreading the error checking logic around the project,
   * we call it here when (and only when) a command needs to use the API
   */

};
const defaults = {
  requireUser: true,
  requireProject: true
};

const authErrors = () => ({
  onError: err => {
    if (envAuthToken || !err || !err.response) {
      return err;
    }

    const body = err.response.body;

    if (!body || body.statusCode !== 401) {
      return err;
    }

    const cfg = (0, _getUserConfig.default)();
    cfg.delete('authType');
    cfg.delete('authToken'); // @todo Trigger re-authentication?

    return err;
  }
});

function clientWrapper(manifest, configPath) {
  const requester = _client.default.requester.clone();

  requester.use(authErrors());
  return function (opts = {}) {
    const {
      requireUser,
      requireProject,
      api
    } = _objectSpread({}, defaults, {}, opts);

    const userConfig = (0, _getUserConfig.default)();
    const userApiConf = userConfig.get('api');
    const token = envAuthToken || userConfig.get('authToken');
    const apiHost = apiHosts[sanityEnv];
    const apiConfig = Object.assign({}, userApiConf || {}, manifest && manifest.api || {}, api || {});

    if (apiHost) {
      apiConfig.apiHost = apiHost;
    }

    if (requireUser && !token) {
      throw new Error('You must login first - run "sanity login"');
    }

    if (requireProject && !apiConfig.projectId) {
      throw new Error(`"${configPath}" does not contain a project identifier ("api.projectId"), ` + 'which is required for the Sanity CLI to communicate with the Sanity API');
    }

    return (0, _client.default)(_objectSpread({}, apiConfig, {
      dataset: apiConfig.dataset || 'dummy',
      token: token,
      useProjectHostname: requireProject,
      requester: requester,
      useCdn: false
    }));
  };
}