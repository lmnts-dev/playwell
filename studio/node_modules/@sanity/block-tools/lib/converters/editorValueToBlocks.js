"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = editorValueToBlocks;

var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _randomKey = _interopRequireDefault(require("../util/randomKey"));

var _normalizeBlock = _interopRequireDefault(require("../util/normalizeBlock"));

var _constants = require("../constants");

var _blockContentTypeFeatures = _interopRequireDefault(require("../util/blockContentTypeFeatures"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createCustomBlockFromData(block) {
  var value = block.data.value;

  if (!value) {
    throw new Error("Data got no value: ".concat(JSON.stringify(block.data)));
  }

  var finalBlock = _objectSpread({}, value);

  finalBlock._key = block.key || (0, _randomKey.default)(12);

  if (!finalBlock._type) {
    throw new Error("The block must have a _type: ".concat(JSON.stringify(value)));
  }

  return finalBlock;
}

function toSanitySpan(node, sanityBlock, spanIndex, blockContentFeatures) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var allowedDecorators = blockContentFeatures.decorators.map(decorator => decorator.value);

  if (node.object === 'text') {
    return node.leaves.map(leaf => {
      return {
        _type: 'span',
        _key: "".concat(sanityBlock._key).concat(spanIndex()),
        text: leaf.text,
        marks: (0, _uniq2.default)(leaf.marks.map(mark => mark.type).filter(markType => allowedDecorators.includes(markType)))
      };
    });
  }

  if (node.object === 'inline') {
    var nodes = node.nodes,
        data = node.data;
    var annotations = data.annotations;
    var annotationKeys = [];

    if (annotations) {
      Object.keys(annotations).forEach(name => {
        var annotation = annotations[name];
        var annotationKey = annotation._key;

        if (annotation && annotationKey) {
          sanityBlock.markDefs.push(annotation);
          annotationKeys.push(annotationKey);
        }
      });
    }

    return (0, _flatten2.default)(nodes.map(nodesNode => {
      if (nodesNode.object !== 'text') {
        throw new Error("Unexpected non-text child node for inline text: ".concat(nodesNode.object));
      }

      if (node.type !== 'span') {
        return node.data.value;
      }

      return nodesNode.leaves.map(leaf => ({
        _type: 'span',
        _key: "".concat(sanityBlock._key).concat(spanIndex()),
        text: leaf.text,
        marks: (0, _uniq2.default)(leaf.marks.map(mark => mark.type).filter(markType => allowedDecorators.includes(markType)).concat(annotationKeys))
      }));
    }));
  }

  throw new Error("Unsupported object ".concat(node.object));
}

function toSanityBlock(block, blockContentFeatures) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Handle block type
  if (block.type === 'contentBlock') {
    var sanityBlock = _objectSpread({}, block.data, {
      _type: 'block',
      markDefs: []
    });

    var index = 0;

    var spanIndex = () => {
      return index++;
    };

    sanityBlock._key = block.key || (0, _randomKey.default)(12);

    if (!sanityBlock.style) {
      sanityBlock.style = _constants.BLOCK_DEFAULT_STYLE;
    }

    sanityBlock.children = (0, _flatten2.default)(block.nodes.map(node => toSanitySpan(node, sanityBlock, spanIndex, blockContentFeatures, options)));
    sanityBlock.markDefs = (0, _uniqBy2.default)(sanityBlock.markDefs, def => def._key);
    return sanityBlock;
  } // Handle block objects


  if (blockContentFeatures.types.blockObjects.map(bObj => bObj.name).includes(block.type)) {
    return createCustomBlockFromData(block);
  } // Put the right type back on the block if marked as __unknown from blocksToEditorValue


  if (block.type === '__unknown') {
    block.type = block.data.value._type;
    return createCustomBlockFromData(_objectSpread({}, block, {
      type: block.data.value._type
    }));
  } // A block that is not in the schema, so we don't know what to do with it


  throw new Error("Unknown block type: '".concat(block.type, "'"));
}

function editorValueToBlocks(value, type) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var blockContentFeatures = (0, _blockContentTypeFeatures.default)(type);
  var nodes = (0, _get2.default)(value, 'document.nodes');

  if (!nodes || nodes.length === 0) {
    return [];
  }

  return nodes.map(node => toSanityBlock(node, blockContentFeatures, options)).filter(Boolean).map(_normalizeBlock.default);
}