"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _dropdown = _interopRequireDefault(require("part:@sanity/components/buttons/dropdown"));

var _default = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _blockObjectIcon = _interopRequireDefault(require("part:@sanity/base/block-object-icon"));

var _inlineObjectIcon = _interopRequireDefault(require("part:@sanity/base/inline-object-icon"));

var _reactTippy = require("react-tippy");

var _paths = require("@sanity/util/paths");

var _InsertMenu = _interopRequireDefault(require("./styles/InsertMenu.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InsertMenu extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "renderItem", item => {
      var Icon = item.icon;
      return _react.default.createElement("div", {
        className: _InsertMenu.default.item
      }, Icon && _react.default.createElement("div", {
        className: _InsertMenu.default.icon
      }, _react.default.createElement(Icon, null)), item.title);
    });

    _defineProperty(this, "renderButton", item => {
      var showLabels = this.props.showLabels;
      return _react.default.createElement(_reactTippy.Tooltip, {
        title: "Insert ".concat(item.title),
        disabled: this.props.collapsed,
        key: "insertMenuItem_".concat(item.key),
        style: showLabels ? {
          display: 'block',
          flexGrow: 1,
          minWidth: 'fit-content'
        } : {}
      }, _react.default.createElement(_default.default, {
        onClick: () => this.handleOnAction(item),
        title: "Insert ".concat(item.title),
        "aria-label": "Insert ".concat(item.title),
        icon: item.icon,
        kind: "simple",
        bleed: true
      }, showLabels && item.title));
    });

    _defineProperty(this, "getIcon", (type, fallbackIcon) => {
      var referenceIcon = (0, _get2.default)(type, 'to[0].icon');
      return type.icon || type.type && type.type.icon || referenceIcon || fallbackIcon;
    });

    _defineProperty(this, "handleOnAction", item => {
      var _this$props = this.props,
          onFocus = _this$props.onFocus,
          editor = _this$props.editor;
      var focusPath;

      if (item.isInline) {
        editor.command('insertInlineObject', {
          objectType: item.value
        });
        focusPath = [{
          _key: editor.value.focusBlock.key
        }, 'children', {
          _key: editor.value.focusInline.key
        }, _paths.FOCUS_TERMINATOR];
      } else {
        editor.command('insertBlockObject', {
          objectType: item.value
        });
        focusPath = [{
          _key: editor.value.focusBlock.key
        }, _paths.FOCUS_TERMINATOR];
      }

      setTimeout(() => onFocus(focusPath), 200);
    });
  }

  shouldComponentUpdate(nextProps) {
    return this.props.collapsed !== nextProps.collapsed || this.props.blockTypes !== nextProps.blockTypes || this.props.inlineTypes !== nextProps.inlineTypes || this.props.editorValue.focusBlock !== nextProps.editorValue.focusBlock;
  }

  getItems() {
    var editor = this.props.editor;
    var focusBlock = editor.value.focusBlock;
    var blockItems = this.props.blockTypes.map(type => ({
      title: type.title,
      value: type,
      icon: this.getIcon(type, _blockObjectIcon.default),
      isInline: false,
      isDisabled: false
    }));
    var inlineItems = this.props.inlineTypes.map(type => ({
      title: type.title,
      icon: this.getIcon(type, _inlineObjectIcon.default),
      value: type,
      isInline: true,
      isDisabled: focusBlock ? editor.query('isVoid', focusBlock) : true
    }));
    return blockItems.concat(inlineItems);
  }

  render() {
    var collapsed = this.props.collapsed;
    var items = this.getItems();

    if (!collapsed) {
      return items.map((item, key) => _objectSpread({}, item, {
        key
      })).map(this.renderButton);
    }

    return _react.default.createElement(_dropdown.default, {
      items: items,
      renderItem: this.renderItem,
      onAction: this.handleOnAction,
      kind: "simple"
    }, "Insert");
  }

}

exports.default = InsertMenu;