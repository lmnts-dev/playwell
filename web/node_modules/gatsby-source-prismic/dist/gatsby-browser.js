'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var md5 = _interopDefault(require('md5'));
var queryString = _interopDefault(require('query-string'));
var yup = require('yup');

const IS_BROWSER = typeof window !== 'undefined';
const GLOBAL_STORE_KEY = '___PRISMIC___';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const isFunction = x => !!(x && x.constructor && x.call && x.apply); // See: lodash.pick

const omit = fields => obj => Object.keys(obj).reduce((acc, key) => {
  if (!fields.includes(key)) acc[key] = obj[key];
  return acc;
}, {}); // Maps an object to a new object with key-value pairs. Mapping function must

const baseValidations = {
  repositoryName: yup.string().nullable().required(),
  accessToken: yup.string().nullable().required(),
  linkResolver: yup.mixed().test('is function', '${path} is not a function', isFunction).default(() => () => {}),
  fetchLinks: yup.array().of(yup.string().required()).default([]),
  htmlSerializer: yup.mixed().test('is function', '${path} is not a function', isFunction).default(() => () => {}),
  schemas: yup.object().nullable().required(),
  lang: yup.string().nullable().default('*'),
  shouldNormalizeImage: yup.mixed().test('is function', '${path} is not a function', isFunction).default(() => () => true),
  plugins: yup.array().max(0).default([])
};
const validatePluginOptions = function validatePluginOptions(pluginOptions) {
  let requireSchemas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const schema = yup.object().shape(_objectSpread2({}, baseValidations, {
    schemas: requireSchemas ? baseValidations.schemas : undefined,
    typePathsFilenamePrefix: yup.string().nullable().default("prismic-typepaths---".concat(pluginOptions.repositoryName, "-"))
  }));
  return schema.validate(pluginOptions, {
    abortEarly: false
  });
};

const onClientEntry = async (_, rawPluginOptions) => {
  if (!IS_BROWSER) return;
  const searchParams = queryString.parse(window.location.search);
  const isPreviewSession = searchParams.token && searchParams.documentId;

  if (isPreviewSession) {
    const pluginOptions = await validatePluginOptions(omit(['schemas', 'plugins'])(rawPluginOptions), false);
    const schemasDigest = md5(JSON.stringify(rawPluginOptions.schemas));
    window[GLOBAL_STORE_KEY] = window[GLOBAL_STORE_KEY] || {};
    Object.assign(window[GLOBAL_STORE_KEY], {
      [rawPluginOptions.repositoryName]: {
        pluginOptions,
        schemasDigest
      }
    });
  }
};

exports.onClientEntry = onClientEntry;
//# sourceMappingURL=gatsby-browser.js.map
