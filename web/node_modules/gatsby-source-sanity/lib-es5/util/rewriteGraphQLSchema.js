"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var graphql_1 = require("gatsby/graphql");
var normalize_1 = require("./normalize");
var conflictPrefix = 'sanity';
var builtins = ['ID', 'String', 'Boolean', 'Int', 'Float', 'JSON', 'DateTime', 'Date'];
var wantedNodeTypes = ['ObjectTypeDefinition', 'UnionTypeDefinition', 'InterfaceTypeDefinition'];
exports.rewriteGraphQLSchema = function (schemaSdl, config) {
    var ast = graphql_1.parse(schemaSdl);
    var transformedAst = transformAst(ast, config);
    var transformed = graphql_1.print(transformedAst);
    return transformed;
};
function transformAst(ast, config) {
    return __assign({}, ast, { definitions: ast.definitions.filter(isWantedAstNode).map(transformDefinitionNode) });
}
function isWantedAstNode(astNode) {
    var node = astNode;
    return wantedNodeTypes.includes(node.kind) && node.name.value !== 'RootQuery';
}
function transformDefinitionNode(node) {
    switch (node.kind) {
        case 'ObjectTypeDefinition':
            return transformObjectTypeDefinition(node);
        case 'UnionTypeDefinition':
            return transformUnionTypeDefinition(node);
        case 'InterfaceTypeDefinition':
            return transformInterfaceTypeDefinition(node);
        default:
            return node;
    }
}
function transformObjectTypeDefinition(node) {
    var fields = node.fields || [];
    var jsonTargets = fields.map(getJsonAliasTargets).filter(Boolean);
    var blockFields = jsonTargets.map(makeBlockField);
    var interfaces = (node.interfaces || []).map(maybeRewriteType);
    var isDocumentType = interfaces.some(function (item) { return item.kind === 'NamedType' && item.name.value === 'SanityDocument'; });
    // Implement Gatsby node interface if it is a document
    if (isDocumentType) {
        interfaces.push({ kind: 'NamedType', name: { kind: 'Name', value: 'Node' } });
    }
    return __assign({}, node, { name: __assign({}, node.name, { value: getTypeName(node.name.value) }), interfaces: interfaces, directives: [{ kind: 'Directive', name: { kind: 'Name', value: 'dontInfer' } }], fields: fields.filter(function (field) { return !getJsonAliasTargets(field); }).map(transformFieldNodeAst).concat(blockFields) });
}
function transformUnionTypeDefinition(node) {
    return __assign({}, node, { types: (node.types || []).map(maybeRewriteType), name: __assign({}, node.name, { value: getTypeName(node.name.value) }) });
}
function transformInterfaceTypeDefinition(node) {
    var fields = node.fields || [];
    return __assign({}, node, { fields: fields.map(transformFieldNodeAst), name: __assign({}, node.name, { value: getTypeName(node.name.value) }) });
}
function unwrapType(typeNode) {
    if (['NonNullType', 'ListType'].includes(typeNode.kind)) {
        var wrappedType = typeNode;
        return unwrapType(wrappedType.type);
    }
    return typeNode;
}
function getJsonAliasTargets(field) {
    var alias = (field.directives || []).find(function (dir) { return dir.name.value === 'jsonAlias'; });
    if (!alias) {
        return null;
    }
    var forArg = (alias.arguments || []).find(function (arg) { return arg.name.value === 'for'; });
    if (!forArg) {
        return null;
    }
    return graphql_1.valueFromAST(forArg.value, graphql_1.GraphQLString, {});
}
function makeBlockField(name) {
    return {
        kind: 'FieldDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        arguments: [],
        directives: [],
        type: {
            kind: 'ListType',
            type: {
                kind: 'NamedType',
                name: {
                    kind: 'Name',
                    value: 'SanityBlock',
                },
            },
        },
    };
}
function makeNullable(nodeType) {
    if (nodeType.kind === 'NamedType') {
        return maybeRewriteType(nodeType);
    }
    if (nodeType.kind === 'ListType') {
        var unwrapped = maybeRewriteType(unwrapType(nodeType));
        return {
            kind: 'ListType',
            type: makeNullable(unwrapped),
        };
    }
    return maybeRewriteType(nodeType.type);
}
function transformFieldNodeAst(node) {
    var field = __assign({}, node, { name: maybeRewriteFieldName(node), type: rewireIdType(makeNullable(node.type)), description: undefined, directives: [] });
    if (field.type.kind === 'NamedType' && field.type.name.value === 'Date') {
        field.directives.push({ kind: 'Directive', name: { kind: 'Name', value: 'dateformat' } });
    }
    return field;
}
function rewireIdType(nodeType) {
    if (nodeType.kind === 'NamedType' && nodeType.name.value === 'ID') {
        return __assign({}, nodeType, { name: { kind: 'Name', value: 'String' } });
    }
    return nodeType;
}
function maybeRewriteType(nodeType) {
    var type = nodeType;
    if (typeof type.name === 'undefined') {
        return nodeType;
    }
    // Gatsby has a date type, but not a datetime, so rewire it
    if (type.name.value === 'DateTime') {
        return __assign({}, type, { name: { kind: 'Name', value: 'Date' } });
    }
    if (builtins.includes(type.name.value)) {
        return type;
    }
    return __assign({}, type, { name: { kind: 'Name', value: getTypeName(type.name.value) } });
}
function maybeRewriteFieldName(field) {
    if (!normalize_1.RESTRICTED_NODE_FIELDS.includes(field.name.value)) {
        return field.name;
    }
    return __assign({}, field.name, { value: "" + conflictPrefix + lodash_1.upperFirst(field.name.value) });
}
function getTypeName(name) {
    return name.startsWith('Sanity') ? name : "Sanity" + name;
}
//# sourceMappingURL=rewriteGraphQLSchema.js.map