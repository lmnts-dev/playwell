"use strict";

exports.__esModule = true;
exports["default"] = exports.isNaNPolyfill = void 0;

var _curry = _interopRequireDefault(require("ramda/src/internal/_curry1"));

var _isFunction = _interopRequireDefault(require("./isFunction"));

var _Number = _interopRequireDefault(require("./internal/polyfills/Number.isNaN"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isNaNPolyfill = (0, _curry["default"])(_Number["default"]);
/**
 * Checks whether the passed value is `NaN` and its type is `Number`.
 * It is a more robust version of the original, global isNaN().
 *
 *
 * @func isNaN
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotNaN|isNotNaN}
 * @example
 *
 * RA.isNaN(NaN); // => true
 * RA.isNaN(Number.NaN); // => true
 * RA.isNaN(0 / 0); // => true
 *
 * // e.g. these would have been true with global isNaN().
 * RA.isNaN('NaN'); // => false
 * RA.isNaN(undefined); // => false
 * RA.isNaN({}); // => false
 * RA.isNaN('blabla'); // => false
 *
 * RA.isNaN(true); // => false
 * RA.isNaN(null); // => false
 * RA.isNaN(37); // => false
 * RA.isNaN('37'); // => false
 * RA.isNaN('37.37'); // => false
 * RA.isNaN(''); // => false
 * RA.isNaN(' '); // => false
 */

exports.isNaNPolyfill = isNaNPolyfill;

var _isNaN = (0, _isFunction["default"])(Number.isNaN) ? (0, _curry["default"])(Number.isNaN) : isNaNPolyfill;

var _default = _isNaN;
exports["default"] = _default;