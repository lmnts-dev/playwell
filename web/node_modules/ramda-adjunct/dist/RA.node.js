(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ramda"));
	else if(typeof define === 'function' && define.amd)
		define(["ramda"], factory);
	else if(typeof exports === 'object')
		exports["RA"] = factory(require("ramda"));
	else
		root["RA"] = factory(root["ramda"]);
})(global, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var _isPlaceholder = /*#__PURE__*/__webpack_require__(6);

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
module.exports = _curry1;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}
module.exports = _isString;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}
module.exports = _isObject;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

function _isNumber(x) {
  return Object.prototype.toString.call(x) === '[object Number]';
}
module.exports = _isNumber;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

function _isPlaceholder(a) {
       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}
module.exports = _isPlaceholder;

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "ramda"
var external_ramda_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/stubUndefined.js

/**
 * A function that returns `undefined`.
 *
 * @func stubUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.0.0|v1.0.0}
 * @category Function
 * @sig ... -> undefined
 * @return {undefined}
 * @example
 *
 * RA.stubUndefined(); //=> undefined
 * RA.stubUndefined(1, 2, 3); //=> undefined
 */

var stubUndefined = Object(external_ramda_["always"])(void 0); // eslint-disable-line no-void

/* harmony default export */ var src_stubUndefined = (stubUndefined);
// CONCATENATED MODULE: ./src/isUndefined.js


/**
 * Checks if input value is `undefined`.
 *
 * @func isUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.0.1|v0.0.1}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotUndefined|isNotUndefined}
 * @example
 *
 * RA.isUndefined(1); //=> false
 * RA.isUndefined(undefined); //=> true
 * RA.isUndefined(null); //=> false
 */

var isUndefined = Object(external_ramda_["equals"])(src_stubUndefined());
/* harmony default export */ var src_isUndefined = (isUndefined);
// CONCATENATED MODULE: ./src/isNotUndefined.js


/**
 * Checks if input value is complement `undefined`.
 *
 * @func isNotUndefined
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.0.1|v0.0.1}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isUndefined|isUndefined}
 * @example
 *
 * RA.isNotUndefined(1); //=> true
 * RA.isNotUndefined(undefined); //=> false
 * RA.isNotUndefined(null); //=> true
 */

var isNotUndefined = Object(external_ramda_["complement"])(src_isUndefined);
/* harmony default export */ var src_isNotUndefined = (isNotUndefined);
// CONCATENATED MODULE: ./src/isNull.js

/**
 * Checks if input value is `null`.
 *
 * @func isNull
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotNull|isNotNull}
 * @example
 *
 * RA.isNull(1); //=> false
 * RA.isNull(undefined); //=> false
 * RA.isNull(null); //=> true
 */

var isNull = Object(external_ramda_["equals"])(null);
/* harmony default export */ var src_isNull = (isNull);
// CONCATENATED MODULE: ./src/isNotNull.js


/**
 * Checks if input value is complement of `null`.
 *
 * @func isNotNull
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.1.0|v0.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNull|isNull}
 * @example
 *
 * RA.isNotNull(1); //=> true
 * RA.isNotNull(undefined); //=> true
 * RA.isNotNull(null); //=> false
 */

var isNotNull = Object(external_ramda_["complement"])(src_isNull);
/* harmony default export */ var src_isNotNull = (isNotNull);
// CONCATENATED MODULE: ./src/isNotNil.js

/**
 * Checks if input value is complement of `null` or `undefined`.
 *
 * @func isNotNil
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#isNil|R.isNil}
 * @example
 *
 * RA.isNotNil(null); //=> false
 * RA.isNotNil(undefined); //=> false
 * RA.isNotNil(0); //=> true
 * RA.isNotNil([]); //=> true
 */

var isNotNil = Object(external_ramda_["complement"])(external_ramda_["isNil"]);
/* harmony default export */ var src_isNotNil = (isNotNil);
// EXTERNAL MODULE: ./node_modules/ramda/src/internal/_curry1.js
var _curry1 = __webpack_require__(1);
var _curry1_default = /*#__PURE__*/__webpack_require__.n(_curry1);

// EXTERNAL MODULE: ./node_modules/ramda/src/internal/_isArray.js
var _isArray = __webpack_require__(2);
var _isArray_default = /*#__PURE__*/__webpack_require__.n(_isArray);

// CONCATENATED MODULE: ./src/isGeneratorFunction.js


var GeneratorFunction = null;
var legacyCheck = null;

try {
  GeneratorFunction = new Function('return function* () {}')().constructor; // eslint-disable-line no-new-func

  legacyCheck = Object(external_ramda_["is"])(GeneratorFunction);
} catch (e) {
  legacyCheck = external_ramda_["F"];
}
/**
 * Checks if input value is `Generator Function`.
 *
 * @func isGeneratorFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isAsyncFunction}, {@link RA.isNotGeneratorFunction|isNotGeneratorFunction}
 * @example
 *
 * RA.isGeneratorFunction(function* test() { }); //=> true
 * RA.isGeneratorFunction(null); //=> false
 * RA.isGeneratorFunction(function test() { }); //=> false
 * RA.isGeneratorFunction(() => {}); //=> false
 */


var isGeneratorFunction = _curry1_default()(Object(external_ramda_["either"])(Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('GeneratorFunction')), legacyCheck));
/* harmony default export */ var src_isGeneratorFunction = (isGeneratorFunction);
// CONCATENATED MODULE: ./src/isAsyncFunction.js


/**
 * Checks if input value is `Async Function`.
 *
 * @func isAsyncFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isNotAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isAsyncFunction(async function test() { }); //=> true
 * RA.isAsyncFunction(null); //=> false
 * RA.isAsyncFunction(function test() { }); //=> false
 * RA.isAsyncFunction(() => {}); //=> false
 */

var isAsyncFunction = _curry1_default()(Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('AsyncFunction')));
/* harmony default export */ var src_isAsyncFunction = (isAsyncFunction);
// CONCATENATED MODULE: ./src/isFunction.js



/**
 * Checks if input value is `Function`.
 *
 * @func isFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotFunction|isNotFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isFunction(function test() { }); //=> true
 * RA.isFunction(function* test() { }); //=> true
 * RA.isFunction(async function test() { }); //=> true
 * RA.isFunction(() => {}); //=> true
 * RA.isFunction(null); //=> false
 * RA.isFunction('abc'); //=> false
 */

var isFunction = Object(external_ramda_["anyPass"])([Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('Function')), src_isGeneratorFunction, src_isAsyncFunction]);
/* harmony default export */ var src_isFunction = (isFunction);
// CONCATENATED MODULE: ./src/isArray.js



/**
 * Checks if input value is `Array`.
 *
 * @func isArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotArray|isNotArray}
 * @example
 *
 * RA.isArray([]); //=> true
 * RA.isArray(null); //=> false
 * RA.isArray({}); //=> false
 */

var isArray = _curry1_default()(src_isFunction(Array.isArray) ? Array.isArray : _isArray_default.a);
/* harmony default export */ var src_isArray = (isArray);
// CONCATENATED MODULE: ./src/isIterable.js



/**
 * Checks whether the passed value is iterable.
 *
 * @func isIterable
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.18.0|v2.18.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol}
 * @return {boolean}
 * @example
 *
 * RA.isIterable(['arrays', 'are', 'iterable']); //=> true
 * RA.isIterable('strings are iterable, too'); //=> true
 * RA.isIterable((function* () {})()); //=> true (generator objects are both iterable and iterators)
 *
 * RA.isIterable({}); //=> false
 * RA.isIterable(-0); //=> false
 * RA.isIterable(null); //=> false
 * RA.isIterable(undefined); //=> false
 */

var isIterable = _curry1_default()(function (val) {
  if (typeof Symbol === 'undefined') {
    return false;
  }

  return Object(external_ramda_["hasIn"])(Symbol.iterator, Object(val)) && src_isFunction(val[Symbol.iterator]);
});
/* harmony default export */ var src_isIterable = (isIterable);
// CONCATENATED MODULE: ./src/isEmptyArray.js


/**
 * Checks if input value is an empty `Array`.
 *
 * @func isEmptyArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotEmptyArray|isNotEmptyArray}
 * @example
 *
 * RA.isEmptyArray([]); // => true
 * RA.isEmptyArray([42]); // => false
 * RA.isEmptyArray({}); // => false
 * RA.isEmptyArray(null); // => false
 * RA.isEmptyArray(undefined); // => false
 * RA.isEmptyArray(42); // => false
 * RA.isEmptyArray('42'); // => false
 */

var isEmptyArray = Object(external_ramda_["both"])(src_isArray, external_ramda_["isEmpty"]);
/* harmony default export */ var src_isEmptyArray = (isEmptyArray);
// CONCATENATED MODULE: ./src/isNotArray.js


/**
 * Checks if input value is complement of `Array`
 *
 * @func isNotArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isArray|isArray}
 * @example
 *
 * RA.isNotArray([]); //=> false
 * RA.isNotArray(null); //=> true
 * RA.isNotArray({}); //=> true
 */

var isNotArray = Object(external_ramda_["complement"])(src_isArray);
/* harmony default export */ var src_isNotArray = (isNotArray);
// CONCATENATED MODULE: ./src/isNotEmpty.js

/**
 * Returns true if the given value is not its type's empty value; `false` otherwise.
 *
 * @func isNotEmpty
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
 * @category Logic
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#isEmpty|R.isEmpty}
 * @example
 *
 * RA.isNotEmpty([1, 2, 3]); //=> true
 * RA.isNotEmpty([]); //=> false
 * RA.isNotEmpty(''); //=> false
 * RA.isNotEmpty(null); //=> true
 * RA.isNotEmpty(undefined): //=> true
 * RA.isNotEmpty({}); //=> false
 * RA.isNotEmpty({length: 0}); //=> true
 */

var isNotEmpty = Object(external_ramda_["complement"])(external_ramda_["isEmpty"]);
/* harmony default export */ var src_isNotEmpty = (isNotEmpty);
// CONCATENATED MODULE: ./src/isNonEmptyArray.js



/**
 * Checks if input value is not an empty `Array`.
 *
 * @func isNonEmptyArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isEmptyArray|isEmptyArray}
 * @example
 *
 * RA.isNonEmptyArray([42]); // => true
 * RA.isNonEmptyArray([]); // => false
 * RA.isNonEmptyArray({}); // => false
 * RA.isNonEmptyArray(null); // => false
 * RA.isNonEmptyArray(undefined); // => false
 * RA.isNonEmptyArray(42); // => false
 * RA.isNonEmptyArray('42'); // => false
 */

var isNonEmptyArray = Object(external_ramda_["both"])(src_isArray, src_isNotEmpty);
/* harmony default export */ var src_isNonEmptyArray = (isNonEmptyArray);
// CONCATENATED MODULE: ./src/isBoolean.js


/**
 * Checks if input value is `Boolean`.
 *
 * @func isBoolean
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotBoolean|isNotBoolean}
 * @example
 *
 * RA.isBoolean(false); //=> true
 * RA.isBoolean(true); //=> true
 * RA.isBoolean(null); //=> false
 */

var isBoolean = _curry1_default()(Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('Boolean')));
/* harmony default export */ var src_isBoolean = (isBoolean);
// CONCATENATED MODULE: ./src/isNotBoolean.js


/**
 * Checks if input value is complement of `Boolean`.
 *
 * @func isNotBoolean
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.3.0|v0.3.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isBoolean|isBoolean}
 * @example
 *
 * RA.isNotBoolean(false); //=> false
 * RA.isNotBoolean(true); //=> false
 * RA.isNotBoolean(null); //=> true
 */

var isNotBoolean = Object(external_ramda_["complement"])(src_isBoolean);
/* harmony default export */ var src_isNotBoolean = (isNotBoolean);
// CONCATENATED MODULE: ./src/isNilOrEmpty.js


/**
 * Returns `true` if the given value is its type's empty value, `null` or `undefined`.
 *
 * @func isNilOrEmpty
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#isEmpty|R.isEmpty}, {@link http://ramdajs.com/docs/#isNil|R.isNil}
 * @example
 *
 * RA.isNilOrEmpty([1, 2, 3]); //=> false
 * RA.isNilOrEmpty([]); //=> true
 * RA.isNilOrEmpty(''); //=> true
 * RA.isNilOrEmpty(null); //=> true
 * RA.isNilOrEmpty(undefined): //=> true
 * RA.isNilOrEmpty({}); //=> true
 * RA.isNilOrEmpty({length: 0}); //=> false
 */

var isNilOrEmpty = _curry1_default()(Object(external_ramda_["either"])(external_ramda_["isNil"], external_ramda_["isEmpty"]));
/* harmony default export */ var src_isNilOrEmpty = (isNilOrEmpty);
// EXTERNAL MODULE: ./node_modules/ramda/src/internal/_isString.js
var _isString = __webpack_require__(3);
var _isString_default = /*#__PURE__*/__webpack_require__.n(_isString);

// CONCATENATED MODULE: ./src/isString.js

/**
 * Checks if input value is `String`.
 *
 * @func isString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotString|isNotString}
 * @example
 *
 * RA.isString('abc'); //=> true
 * RA.isString(1); //=> false
 */

var isString = _isString_default.a;
/* harmony default export */ var src_isString = (isString);
// CONCATENATED MODULE: ./src/isEmptyString.js

/**
 * Checks if input value is an empty `String`.
 *
 * @func isEmptyString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotEmptyString|isNotEmptyString}
 * @example
 *
 * RA.isEmptyString(''); // => true
 * RA.isEmptyString('42'); // => false
 * RA.isEmptyString(new String('42')); // => false
 * RA.isEmptyString(new String('')); // => false
 * RA.isEmptyString([42]); // => false
 * RA.isEmptyString({}); // => false
 * RA.isEmptyString(null); // => false
 * RA.isEmptyString(undefined); // => false
 * RA.isEmptyString(42); // => false
 */

var isEmptyString = Object(external_ramda_["equals"])('');
/* harmony default export */ var src_isEmptyString = (isEmptyString);
// CONCATENATED MODULE: ./src/isNotString.js


/**
 * Checks if input value is complement of `String`.
 *
 * @func isNotString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.4.0|v0.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isString|isString}
 * @example
 *
 * RA.isNotString('abc'); //=> false
 * RA.isNotString(1); //=> true
 */

var isNotString = Object(external_ramda_["complement"])(src_isString);
/* harmony default export */ var src_isNotString = (isNotString);
// CONCATENATED MODULE: ./src/internal/isOfTypeObject.js
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isOfTypeObject = function isOfTypeObject(val) {
  return _typeof(val) === 'object';
};

/* harmony default export */ var internal_isOfTypeObject = (isOfTypeObject);
// CONCATENATED MODULE: ./src/isObj.js




/* eslint-disable max-len */

/**
 * Checks if input value is language type of `Object`.
 *
 * @func isObj
 * @aliases isObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotObj|isNotObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isObj({}); //=> true
 * RA.isObj([]); //=> true
 * RA.isObj(() => {}); //=> true
 * RA.isObj(null); //=> false
 * RA.isObj(undefined); //=> false
 */

/* eslint-enable max-len */

var isObj = Object(external_ramda_["both"])(src_isNotNull, Object(external_ramda_["either"])(internal_isOfTypeObject, src_isFunction));
/* harmony default export */ var src_isObj = (isObj);
// CONCATENATED MODULE: ./src/isNotObj.js


/* eslint-disable max-len */

/**
 * Checks if input value is complement of language type of `Object`.
 *
 * @func isNotObj
 * @aliases isNotObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isObj|isObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isNotObj({}); //=> false
 * RA.isNotObj([]); //=> false
 * RA.isNotObj(() => {}); //=> false
 * RA.isNotObj(null); //=> true
 * RA.isNotObj(undefined); //=> true
 */

/* eslint-enable max-len */

var isNotObj = Object(external_ramda_["complement"])(src_isObj);
/* harmony default export */ var src_isNotObj = (isNotObj);
// CONCATENATED MODULE: ./src/isNonEmptyString.js




/**
 * Checks if input value is not an empty `String`.
 *
 * @func isNonEmptyString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isEmptyString|isEmptyString}
 * @example
 *
 * RA.isNonEmptyString('42'); // => true
 * RA.isNonEmptyString(''); // => false
 * RA.isNonEmptyString(new String('42')); // => false
 * RA.isNonEmptyString(new String('')); // => false
 * RA.isNonEmptyString([42]); // => false
 * RA.isNonEmptyString({}); // => false
 * RA.isNonEmptyString(null); // => false
 * RA.isNonEmptyString(undefined); // => false
 * RA.isNonEmptyString(42); // => false
 */

var isNonEmptyString = Object(external_ramda_["allPass"])([src_isString, src_isNotObj, src_isNotEmpty]);
/* harmony default export */ var src_isNonEmptyString = (isNonEmptyString);
// CONCATENATED MODULE: ./src/isArrayLike.js
function isArrayLike_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { isArrayLike_typeof = function _typeof(obj) { return typeof obj; }; } else { isArrayLike_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return isArrayLike_typeof(obj); }





/* eslint-disable max-len */

/**
 * Tests whether or not an object is similar to an array.
 *
 * @func isArrayLike
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.9.0|v1.9.0}
 * @licence https://github.com/ramda/ramda/blob/master/LICENSE.txt
 * @category List
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @returns {boolean} `true` if `val` has a numeric length property and extreme indices defined; `false` otherwise.
 * @see {@link RA.isNotArrayLike|isNotArrayLike}

 * @example
 *
 * RA.isArrayLike([]); //=> true
 * RA.isArrayLike(true); //=> false
 * RA.isArrayLike({}); //=> false
 * RA.isArrayLike({length: 10}); //=> false
 * RA.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */

/* eslint-enable max-len */

var isArrayLike = _curry1_default()(function (val) {
  if (src_isArray(val)) {
    return true;
  }

  if (!val) {
    return false;
  }

  if (src_isString(val)) {
    return false;
  }

  if (isArrayLike_typeof(val) !== 'object') {
    return false;
  }

  if (val.nodeType === 1) {
    return !!val.length;
  }

  if (val.length === 0) {
    return true;
  }

  if (val.length > 0) {
    return Object(external_ramda_["has"])(0, val) && Object(external_ramda_["has"])(val.length - 1, val);
  }

  return false;
});
/* harmony default export */ var src_isArrayLike = (isArrayLike);
/**
 The MIT License (MIT)

 Copyright (c) 2013-2016 Scott Sauyet and Michael Hurley

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/
// CONCATENATED MODULE: ./src/isNotArrayLike.js


/**
 * Tests whether or not an object is similar to an array.
 *
 * @func isNotArrayLike
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isArrayLike|isArrayLike}
 * @example
 *
 * RA.isNotArrayLike([]); //=> false
 * RA.isNotArrayLike(true); //=> true
 * RA.isNotArrayLike({}); //=> true
 * RA.isNotArrayLike({length: 10}); //=> true
 * RA.isNotArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> false
 */

var isNotArrayLike = Object(external_ramda_["complement"])(src_isArrayLike);
/* harmony default export */ var src_isNotArrayLike = (isNotArrayLike);
// CONCATENATED MODULE: ./src/isNotGeneratorFunction.js


/* eslint-disable max-len */

/**
 * Checks if input value is complement of `Generator Function`
 *
 * @func isNotGeneratorFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isNotGeneratorFunction(function* test() { }); //=> false
 * RA.isNotGeneratorFunction(null); //=> true
 * RA.isNotGeneratorFunction(function test() { }); //=> true
 * RA.isNotGeneratorFunction(() => {}); //=> true
 */

/* eslint-enable max-len */

var isNotGeneratorFunction = Object(external_ramda_["complement"])(src_isGeneratorFunction);
/* harmony default export */ var src_isNotGeneratorFunction = (isNotGeneratorFunction);
// CONCATENATED MODULE: ./src/isNotAsyncFunction.js


/* eslint-disable max-len */

/**
 * Checks if input value is complement of `Async Function`
 *
 * @func isNotAsyncFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isNotAsyncFunction(async function test() { }); //=> false
 * RA.isNotAsyncFunction(null); //=> true
 * RA.isNotAsyncFunction(function test() { }); //=> true
 * RA.isNotAsyncFunction(() => {}); //=> true
 */

/* eslint-enable max-len */

var isNotAsyncFunction = Object(external_ramda_["complement"])(src_isAsyncFunction);
/* harmony default export */ var src_isNotAsyncFunction = (isNotAsyncFunction);
// CONCATENATED MODULE: ./src/isNotFunction.js


/* eslint-disable max-len */

/**
 * Checks if input value is complement of `Function`.
 *
 * @func isNotFunction
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFunction|isFunction}, {@link RA.isAsyncFunction|isNotAsyncFunction}, {@link RA.isGeneratorFunction|isGeneratorFunction}
 * @example
 *
 * RA.isNotFunction(function test() { }); //=> false
 * RA.isNotFunction(function* test() { }); //=> false
 * RA.isNotFunction(async function test() { }); //=> false
 * RA.isNotFunction(() => {}); //=> false
 * RA.isNotFunction(null); //=> true
 * RA.isNotFunction('abc'); //=> true
 */

/* eslint-enable max-len */

var isNotFunction = Object(external_ramda_["complement"])(src_isFunction);
/* harmony default export */ var src_isNotFunction = (isNotFunction);
// CONCATENATED MODULE: ./src/isObjLike.js



/* eslint-disable max-len */

/**
 * Checks if value is object-like. A value is object-like if it's not null and has a typeof result of "object".
 *
 * @func isObjLike
 * @aliases isObjectLike
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotObjLike|isNotObjLike}, {@link RA.isObj|isObj}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isObjLike({}); //=> true
 * RA.isObjLike([]); //=> true
 * RA.isObjLike(() => {}); //=> false
 * RA.isObjLike(null); //=> false
 * RA.isObjLike(undefined); //=> false
 */

/* eslint-enable max-len */

var isObjLike = Object(external_ramda_["both"])(src_isNotNull, internal_isOfTypeObject);
/* harmony default export */ var src_isObjLike = (isObjLike);
// CONCATENATED MODULE: ./src/isNotObjLike.js


/* eslint-disable max-len */

/**
 * Checks if value is not object-like. A value is object-like if it's not null and has a typeof result of "object".
 *
 * @func isNotObjLike
 * @aliases isNotObjectLike
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isObjLike|isObjLike}, {@link RA.isObj|isObj}, {@link RA.isPlainObj|isPlainObj}
 * @example
 *
 * RA.isNotObjLike({}); //=> false
 * RA.isNotObjLike([]); //=> false
 * RA.isNotObjLike(() => {}); //=> true
 * RA.isNotObjLike(null); //=> true
 * RA.isNotObjLike(undefined); //=> true
 */

/* eslint-enable max-len */

var isNotObjLike = Object(external_ramda_["complement"])(src_isObjLike);
/* harmony default export */ var src_isNotObjLike = (isNotObjLike);
// EXTERNAL MODULE: ./node_modules/ramda/src/internal/_isObject.js
var _isObject = __webpack_require__(4);
var _isObject_default = /*#__PURE__*/__webpack_require__.n(_isObject);

// CONCATENATED MODULE: ./src/isPlainObj.js





var isObjectConstructor = Object(external_ramda_["pipe"])(external_ramda_["toString"], Object(external_ramda_["equals"])(Object(external_ramda_["toString"])(Object)));
var hasObjectConstructor = Object(external_ramda_["pathSatisfies"])(Object(external_ramda_["both"])(src_isFunction, isObjectConstructor), ['constructor']);
/* eslint-disable max-len */

/**
 * Check to see if an object is a plain object (created using `{}`, `new Object()` or `Object.create(null)`).
 *
 * @func isPlainObj
 * @aliases isPlainObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotPlainObj|isNotPlainObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isObj|isObj}
 * @example
 *
 * class Bar {
 *   constructor() {
 *     this.prop = 'value';
 *   }
 * }
 *
 * RA.isPlainObj(new Bar()); //=> false
 * RA.isPlainObj({ prop: 'value' }); //=> true
 * RA.isPlainObj(['a', 'b', 'c']); //=> false
 * RA.isPlainObj(Object.create(null); //=> true
 * RA.isPlainObj(new Object()); //=> true
 */

/* eslint-enable max-len */

var isPlainObj_isPlainObj = function isPlainObj(val) {
  if (!src_isObjLike(val) || !_isObject_default()(val)) {
    return false;
  }

  var proto = Object.getPrototypeOf(val);

  if (src_isNull(proto)) {
    return true;
  }

  return hasObjectConstructor(proto);
};

/* harmony default export */ var src_isPlainObj = (isPlainObj_isPlainObj);
// CONCATENATED MODULE: ./src/isNotPlainObj.js


/* eslint-disable max-len */

/**
 * Check to see if an object is a not plain object (created using `{}`, `new Object()` or `Object.create(null)`).
 *
 * @func isNotPlainObj
 * @aliases isNotPlainObject
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.5.0|v0.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isPlainObj|isPlainObj}, {@link RA.isObjLike|isObjLike}, {@link RA.isObj|isObj}
 * @example
 *
 * class Bar {
 *   constructor() {
 *     this.prop = 'value';
 *   }
 * }
 *
 * RA.isNotPlainObj(new Bar()); //=> true
 * RA.isNotPlainObj({ prop: 'value' }); //=> false
 * RA.isNotPlainObj(['a', 'b', 'c']); //=> true
 * RA.isNotPlainObj(Object.create(null); //=> false
 * RA.isNotPlainObj(new Object()); //=> false
 */

/* eslint-enable max-len */

var isNotPlainObj = Object(external_ramda_["complement"])(src_isPlainObj);
/* harmony default export */ var src_isNotPlainObj = (isNotPlainObj);
// CONCATENATED MODULE: ./src/isDate.js


/**
 * Checks if value is `Date` object.
 *
 * @func isDate
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotDate|isNotDate}, {@link RA.isValidDate|isValidDate}, {@link RA.isNotValidDate|isNotValidDate}
 * @example
 *
 * RA.isDate(new Date()); //=> true
 * RA.isDate('1997-07-16T19:20+01:00'); //=> false
 */

var isDate = _curry1_default()(Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('Date')));
/* harmony default export */ var src_isDate = (isDate);
// CONCATENATED MODULE: ./src/isNotDate.js


/**
 * Checks if value is complement of `Date` object.
 *
 * @func isNotDate
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isDate|isDate}
 * @example
 *
 * RA.isNotDate(new Date()); //=> false
 * RA.isNotDate('1997-07-16T19:20+01:00'); //=> true
 */

var isNotDate = Object(external_ramda_["complement"])(src_isDate);
/* harmony default export */ var src_isNotDate = (isNotDate);
// EXTERNAL MODULE: ./node_modules/ramda/src/internal/_isNumber.js
var _isNumber = __webpack_require__(5);
var _isNumber_default = /*#__PURE__*/__webpack_require__.n(_isNumber);

// CONCATENATED MODULE: ./src/isNumber.js

/**
 * Checks if value is a `Number` primitive or object.
 *
 * @func isNumber
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotNumber|isNotNumber}
 * @example
 *
 * RA.isNumber(5); // => true
 * RA.isNumber(Number.MAX_VALUE); // => true
 * RA.isNumber(-Infinity); // => true
 * RA.isNumber(NaN); // => true
 * RA.isNumber('5'); // => false
 */

var isNumber = _isNumber_default.a;
/* harmony default export */ var src_isNumber = (isNumber);
// CONCATENATED MODULE: ./src/internal/polyfills/Number.isNaN.js

 // eslint-disable-next-line no-restricted-globals

var isNaNPolyfill = Object(external_ramda_["both"])(src_isNumber, isNaN);
/* harmony default export */ var Number_isNaN = (isNaNPolyfill);
// CONCATENATED MODULE: ./src/isNaN.js


/**
 * Checks whether the passed value is `NaN` and its type is `Number`.
 * It is a more robust version of the original, global isNaN().
 *
 *
 * @func isNaN
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotNaN|isNotNaN}
 * @example
 *
 * RA.isNaN(NaN); // => true
 * RA.isNaN(Number.NaN); // => true
 * RA.isNaN(0 / 0); // => true
 *
 * // e.g. these would have been true with global isNaN().
 * RA.isNaN('NaN'); // => false
 * RA.isNaN(undefined); // => false
 * RA.isNaN({}); // => false
 * RA.isNaN('blabla'); // => false
 *
 * RA.isNaN(true); // => false
 * RA.isNaN(null); // => false
 * RA.isNaN(37); // => false
 * RA.isNaN('37'); // => false
 * RA.isNaN('37.37'); // => false
 * RA.isNaN(''); // => false
 * RA.isNaN(' '); // => false
 */

var _isNaN = _curry1_default()(Number.isNaN || Number_isNaN);

/* harmony default export */ var src_isNaN = (_isNaN);
// CONCATENATED MODULE: ./src/isNotNaN.js


/**
 * Checks whether the passed value is complement of `NaN` and its type is not `Number`.
 *
 * @func isNotNaN
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNaN|isNaN}
 * @example
 *
 * RA.isNotNaN(NaN); // => false
 * RA.isNotNaN(Number.NaN); // => false
 * RA.isNotNaN(0 / 0); // => false
 *
 * RA.isNotNaN('NaN'); // => true
 * RA.isNotNaN(undefined); // => true
 * RA.isNotNaN({}); // => true
 * RA.isNotNaN('blabla'); // => true
 *
 * RA.isNotNaN(true); // => true
 * RA.isNotNaN(null); // => true
 * RA.isNotNaN(37); // => true
 * RA.isNotNaN('37'); // => true
 * RA.isNotNaN('37.37'); // => true
 * RA.isNotNaN(''); // => true
 * RA.isNotNaN(' '); // => true
 */

var isNotNaN = Object(external_ramda_["complement"])(src_isNaN);
/* harmony default export */ var src_isNotNaN = (isNotNaN);
// CONCATENATED MODULE: ./src/isValidDate.js



/* eslint-disable max-len */

/**
 * Checks if value is valid `Date` object.
 *
 * @func isValidDate
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.8.0|v1.8.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isDate|isDate}, {@link RA.isNotDate|isNotDate}, {@link RA.isNotValidDate|isNotValidDate}
 * @example
 *
 * RA.isValidDate(new Date()); //=> true
 * RA.isValidDate(new Date('a')); //=> false
 */

/* eslint-enable max-len */

var isValidDate = Object(external_ramda_["both"])(src_isDate, Object(external_ramda_["pipe"])(Object(external_ramda_["invoker"])(0, 'getTime'), src_isNotNaN));
/* harmony default export */ var src_isValidDate = (isValidDate);
// CONCATENATED MODULE: ./src/isNotValidDate.js


/**
 * Checks if value is complement of valid `Date` object.
 *
 * @func isNotValidDate
 * @aliases isInvalidDate
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.8.0|v1.8.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isValidDate|isValidDate}, {@link RA.isDate|isDate}, {@link RA.isNotDate|isNotDate}
 * @example
 *
 * RA.isNotValidDate(new Date()); //=> false
 * RA.isNotValidDate(new Date('a')); //=> true
 */

var isNotValidDate = Object(external_ramda_["complement"])(src_isValidDate);
/* harmony default export */ var src_isNotValidDate = (isNotValidDate);
// CONCATENATED MODULE: ./src/isNotNumber.js


/**
 * Checks if value is a complement of `Number` primitive or object.
 *
 * @func isNotNumber
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.6.0|v0.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNumber|isNumber}
 * @example
 *
 * RA.isNotNumber(5); // => false
 * RA.isNotNumber(Number.MAX_VALUE); // => false
 * RA.isNotNumber(-Infinity); // => false
 * RA.isNotNumber('5'); // => true
 */

var isNotNumber = Object(external_ramda_["complement"])(src_isNumber);
/* harmony default export */ var src_isNotNumber = (isNotNumber);
// CONCATENATED MODULE: ./src/isPositive.js


/**
 * Checks if value is a positive `Number` primitive or object. Zero is not considered positive.
 *
 * @func isPositive
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.15.0|v1.15.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNegative|isNegative}
 * @example
 *
 * RA.isPositive(1); // => true
 * RA.isPositive(Number.MAX_VALUE); // => true
 * RA.isPositive(-Infinity); // => false
 * RA.isPositive(NaN); // => false
 * RA.isPositive('5'); // => false
 */

var isPositive = Object(external_ramda_["both"])(src_isNumber, Object(external_ramda_["lt"])(0));
/* harmony default export */ var src_isPositive = (isPositive);
// CONCATENATED MODULE: ./src/isNegative.js



/**
 * Checks if value is a negative `Number` primitive or object. Zero is not considered neither
 * positive or negative.
 *
 * @func isNegative
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.15.0|v1.15.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isPositive|isPositive}
 * @example
 *
 * RA.isNegative(-1); // => true
 * RA.isNegative(Number.MIN_VALUE); // => false
 * RA.isNegative(+Infinity); // => false
 * RA.isNegative(NaN); // => false
 * RA.isNegative('5'); // => false
 */

var isNegative = _curry1_default()(Object(external_ramda_["both"])(src_isNumber, Object(external_ramda_["gt"])(0)));
/* harmony default export */ var src_isNegative = (isNegative);
// CONCATENATED MODULE: ./src/isNotNilOrEmpty.js


/**
 * Returns `true` if the given value is its type's empty value, `null` or `undefined`.
 *
 * @func isNotNilOrEmpty
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.18.0|v2.18.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNilOrEmpty|isNilOrEmpty}
 * @example
 *
 * RA.isNotNilOrEmpty([1, 2, 3]); //=> true
 * RA.isNotNilOrEmpty([]); //=> false
 * RA.isNotNilOrEmpty(''); //=> false
 * RA.isNotNilOrEmpty(null); //=> false
 * RA.isNotNilOrEmpty(undefined): //=> false
 * RA.isNotNilOrEmpty({}); //=> false
 * RA.isNotNilOrEmpty({length: 0}); //=> true
 */

var isNotNilOrEmpty = Object(external_ramda_["complement"])(src_isNilOrEmpty);
/* harmony default export */ var src_isNotNilOrEmpty = (isNotNilOrEmpty);
// CONCATENATED MODULE: ./src/isNonPositive.js



/**
 * Checks if value is a non-positive `Number` primitive or object. This includes all negative
 * numbers and zero.
 *
 * @func isNonPositive
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNegative|isNegative}, {@link RA.isNonNegative|isNonNegative}
 * @example
 *
 * RA.isNonPositive(0); // => true
 * RA.isNonPositive(-1); // => true
 * RA.isNonPositive(-Infinity); // => true
 * RA.isNonPositive(Number.MIN_VALUE); // => true
 *
 * RA.isNonPositive(Infinity); // => false
 * RA.isNonPositive(Number.MAX_VALUE); // => false
 * RA.isNonPositive(NaN); // => false
 */

var isNonPositive = _curry1_default()(Object(external_ramda_["both"])(src_isNumber, Object(external_ramda_["flip"])(external_ramda_["lte"])(0)));
/* harmony default export */ var src_isNonPositive = (isNonPositive);
// CONCATENATED MODULE: ./src/isNonNegative.js



/**
 * Checks if value is a non-negative `Number` primitive or object. This includes all positive
 * numbers and zero.
 *
 * @func isNonNegative
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isPositive|isPositive}, {@link RA.isNonPositive|isNonPositive}
 * @example
 *
 * RA.isNonNegative(0); // => true
 * RA.isNonNegative(1); // => true
 * RA.isNonNegative(Infinity); // => true
 * RA.isNonNegative(Number.MAX_VALUE); // => true
 *
 * RA.isNonNegative(-Infinity); // => false
 * RA.isNonNegative(Number.MIN_VALUE); // => false
 * RA.isNonNegative(NaN); // => false
 */

var isNonNegative = _curry1_default()(Object(external_ramda_["both"])(src_isNumber, Object(external_ramda_["flip"])(external_ramda_["gte"])(0)));
/* harmony default export */ var src_isNonNegative = (isNonNegative);
// CONCATENATED MODULE: ./src/internal/polyfills/Number.isFinite.js

 // eslint-disable-next-line no-restricted-globals

var isFinitePolyfill = Object(external_ramda_["both"])(src_isNumber, isFinite);
/* harmony default export */ var Number_isFinite = (isFinitePolyfill);
// CONCATENATED MODULE: ./src/isFinite.js



/**
 * Checks whether the passed value is a finite `Number`.
 *
 * @func isFinite
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.7.0|v0.7.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotFinite|isNotFinite}
 * @example
 *
 * RA.isFinite(Infinity); //=> false
 * RA.isFinite(NaN); //=> false
 * RA.isFinite(-Infinity); //=> false
 *
 * RA.isFinite(0); // true
 * RA.isFinite(2e64); // true
 *
 * RA.isFinite('0');  // => false
 *                    // would've been true with global isFinite('0')
 * RA.isFinite(null); // => false
 *                    // would've been true with global isFinite(null)
 */

var _isFinite = _curry1_default()(src_isFunction(Number.isFinite) ? Number.isFinite : Number_isFinite);

/* harmony default export */ var src_isFinite = (_isFinite);
// CONCATENATED MODULE: ./src/isNotFinite.js


/**
 * Checks whether the passed value is complement of finite `Number`.
 *
 *
 * @func isNotFinite
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.7.0|v0.7.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFinite|isFinite}
 * @example
 *
 * RA.isNotFinite(Infinity); //=> true
 * RA.isNotFinite(NaN); //=> true
 * RA.isNotFinite(-Infinity); //=> true
 *
 * RA.isNotFinite(0); // false
 * RA.isNotFinite(2e64); // false
 *
 * RA.isNotFinite('0');  // => true
 * RA.isNotFinite(null); // => true
 */

var isNotFinite = Object(external_ramda_["complement"])(src_isFinite);
/* harmony default export */ var src_isNotFinite = (isNotFinite);
// CONCATENATED MODULE: ./src/internal/polyfills/Number.isInteger.js


var isIntegerPolyfill = Object(external_ramda_["both"])(src_isFinite, Object(external_ramda_["converge"])(external_ramda_["equals"], [Math.floor, external_ramda_["identity"]]));
/* harmony default export */ var Number_isInteger = (isIntegerPolyfill);
// CONCATENATED MODULE: ./src/isInteger.js


/**
 * Checks whether the passed value is an `integer`.
 *
 * @func isInteger
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.7.0|v0.7.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotInteger|isNotInteger}
 * @example
 *
 * RA.isInteger(0); //=> true
 * RA.isInteger(1); //=> true
 * RA.isInteger(-100000); //=> true
 *
 * RA.isInteger(0.1);       //=> false
 * RA.isInteger(Math.PI);   //=> false
 *
 * RA.isInteger(NaN);       //=> false
 * RA.isInteger(Infinity);  //=> false
 * RA.isInteger(-Infinity); //=> false
 * RA.isInteger('10');      //=> false
 * RA.isInteger(true);      //=> false
 * RA.isInteger(false);     //=> false
 * RA.isInteger([1]);       //=> false
 */

var isInteger = _curry1_default()(Number.isInteger || Number_isInteger);
/* harmony default export */ var src_isInteger = (isInteger);
// CONCATENATED MODULE: ./src/isNotInteger.js


/**
 * Checks whether the passed value is complement of an `integer`.
 *
 *
 * @func isNotInteger
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/0.7.0|v0.7.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isInteger|isInteger}
 * @example
 *
 * RA.isNotInteger(0); //=> false
 * RA.isNotInteger(1); //=> false
 * RA.isNotInteger(-100000); //=> false
 *
 * RA.isNotInteger(0.1);       //=> true
 * RA.isNotInteger(Math.PI);   //=> true
 *
 * RA.isNotInteger(NaN);       //=> true
 * RA.isNotInteger(Infinity);  //=> true
 * RA.isNotInteger(-Infinity); //=> true
 * RA.isNotInteger('10');      //=> true
 * RA.isNotInteger(true);      //=> true
 * RA.isNotInteger(false);     //=> true
 * RA.isNotInteger([1]);       //=> true
 */

var isNotInteger = Object(external_ramda_["complement"])(src_isInteger);
/* harmony default export */ var src_isNotInteger = (isNotInteger);
// CONCATENATED MODULE: ./src/isFloat.js



/**
 * Checks whether the passed value is a `float`.
 *
 * @func isFloat
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.14.0|v1.14.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotFloat|isNotFloat}
 * @example
 *
 * RA.isFloat(0); //=> false
 * RA.isFloat(1); //=> false
 * RA.isFloat(-100000); //=> false
 *
 * RA.isFloat(0.1);       //=> true
 * RA.isFloat(Math.PI);   //=> true
 *
 * RA.isFloat(NaN);       //=> false
 * RA.isFloat(Infinity);  //=> false
 * RA.isFloat(-Infinity); //=> false
 * RA.isFloat('10');      //=> false
 * RA.isFloat(true);      //=> false
 * RA.isFloat(false);     //=> false
 * RA.isFloat([1]);       //=> false
 */

var isFloat = Object(external_ramda_["both"])(src_isFinite, Object(external_ramda_["complement"])(src_isInteger));
/* harmony default export */ var src_isFloat = (isFloat);
// CONCATENATED MODULE: ./src/isNotFloat.js


/**
 * Checks whether the passed value is complement of a `float`.
 *
 * @func isNotFloat
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.14.0|v1.14.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFloat|isFloat}
 * @example
 *
 * RA.isNotFloat(0); //=> true
 * RA.isNotFloat(1); //=> true
 * RA.isNotFloat(-100000); //=> true
 *
 * RA.isNotFloat(0.1);       //=> false
 * RA.isNotFloat(Math.PI);   //=> false
 *
 * RA.isNotFloat(NaN);       //=> true
 * RA.isNotFloat(Infinity);  //=> true
 * RA.isNotFloat(-Infinity); //=> true
 * RA.isNotFloat('10');      //=> true
 * RA.isNotFloat(true);      //=> true
 * RA.isNotFloat(false);     //=> true
 * RA.isNotFloat([1]);       //=> true
 */

var isNotFloat = Object(external_ramda_["complement"])(src_isFloat);
/* harmony default export */ var src_isNotFloat = (isNotFloat);
// CONCATENATED MODULE: ./src/isValidNumber.js



/**
 * Checks if value is a valid `Number`. A valid `Number` is a number that is not `NaN`, `Infinity`
 * or `-Infinity`.
 *
 * @func isValidNumber
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.2.0|v2.2.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotValidNumber|isNotValidNumber}
 * @example
 *
 * RA.isValidNumber(1); //=> true
 * RA.isValidNumber(''); //=> false
 * RA.isValidNumber(NaN); //=> false
 * RA.isValidNumber(Infinity); //=> false
 * RA.isValidNumber(-Infinity); //=> false
 */

var isValidNumber = Object(external_ramda_["either"])(src_isInteger, src_isFloat);
/* harmony default export */ var src_isValidNumber = (isValidNumber);
// CONCATENATED MODULE: ./src/isNotValidNumber.js


/**
 * Checks if value is not a valid `Number`. A valid `Number` is a number that is not `NaN`,
 * `Infinity` or `-Infinity`.
 *
 * @func isNotValidNumber
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.2.0|v2.2.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isValidNumber|isValidNumber}
 * @example
 *
 * RA.isNotValidNumber(1); //=> false
 * RA.isNotValidNumber(''); //=> true
 * RA.isNotValidNumber(NaN); //=> true
 * RA.isNotValidNumber(Infinity); //=> true
 * RA.isNotValidNumber(-Infinity); //=> true
 */

var isNotValidNumber = Object(external_ramda_["complement"])(src_isValidNumber);
/* harmony default export */ var src_isNotValidNumber = (isNotValidNumber);
// CONCATENATED MODULE: ./src/isOdd.js


/**
 * Checks if value is odd integer number.
 * An odd number is an integer which is not a multiple DIVISIBLE of two.
 *
 * @func isOdd
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.18.0|v1.18.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isEven|isEven}
 * @example
 *
 * RA.isOdd(1); // => true
 * RA.isOdd(-Infinity); // => false
 * RA.isOdd(4); // => false
 * RA.isOdd(3); // => true
 */

var isOdd = Object(external_ramda_["both"])(src_isInteger, Object(external_ramda_["pipe"])(Object(external_ramda_["flip"])(external_ramda_["modulo"])(2), Object(external_ramda_["complement"])(external_ramda_["equals"])(0)));
/* harmony default export */ var src_isOdd = (isOdd);
// CONCATENATED MODULE: ./src/isEven.js




/**
 * Checks if value is even integer number.
 * An even number is an integer which is "evenly divisible" by two.
 * Zero is an even number because zero divided by two equals zero,
 * which despite not being a natural number, is an integer.
 * Even numbers are either positive or negative.
 *
 * @func isEven
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.18.0|v1.18.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isOdd|isOdd}
 * @example
 *
 * RA.isEven(0); // => true
 * RA.isEven(1); // => false
 * RA.isEven(-Infinity); // => false
 * RA.isEven(4); // => true
 * RA.isEven(3); // => false
 */

var isEven = _curry1_default()(Object(external_ramda_["both"])(src_isInteger, Object(external_ramda_["complement"])(src_isOdd)));
/* harmony default export */ var src_isEven = (isEven);
// CONCATENATED MODULE: ./src/isPair.js


/**
 * Checks if input value is a pair.
 *
 * @func isPair
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#pair|R.pair}, {@link RA.isNotPair|isNotPair}
 * @example
 *
 * RA.isPair([]); // => false
 * RA.isPair([0]); // => false
 * RA.isPair([0, 1]); // => true
 * RA.isPair([0, 1, 2]); // => false
 * RA.isPair({ 0: 0, 1: 1 }); // => false
 * RA.isPair({ foo: 0, bar: 0 }); // => false
 */

var isPair = Object(external_ramda_["both"])(src_isArray, Object(external_ramda_["pipe"])(external_ramda_["length"], Object(external_ramda_["equals"])(2)));
/* harmony default export */ var src_isPair = (isPair);
// CONCATENATED MODULE: ./src/isNotPair.js


/**
 * Checks if input value is complement of a pair.
 *
 * @func isNotPair
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#pair|R.pair}, {@link RA.isPair|isPair}
 * @example
 *
 * RA.isNotPair([]); // => true
 * RA.isNotPair([0]); // => true
 * RA.isNotPair([0, 1]); // => false
 * RA.isNotPair([0, 1, 2]); // => true
 * RA.isNotPair({0: 0, 1: 1}); // => true
 * RA.isNotPair({foo: 0, bar: 0}); // => true
 */

var isNotPair = Object(external_ramda_["complement"])(src_isPair);
/* harmony default export */ var src_isNotPair = (isNotPair);
// CONCATENATED MODULE: ./src/isThenable.js


/**
 * Checks if input value is a `thenable`.
 * `thenable` is an object or function that defines a `then` method.
 *
 * @func isThenable
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.1.0|v2.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isPromise|isPromise}
 * @example
 *
 * RA.isThenable(null); // => false
 * RA.isThenable(undefined); // => false
 * RA.isThenable([]); // => false
 * RA.isThenable(Promise.resolve()); // => true
 * RA.isThenable(Promise.reject()); // => true
 * RA.isThenable({ then: () => 1 }); // => true
 */

var isThenable = Object(external_ramda_["pathSatisfies"])(src_isFunction, ['then']);
/* harmony default export */ var src_isThenable = (isThenable);
// CONCATENATED MODULE: ./src/isPromise.js


/**
 * Checks if input value is a native `Promise`.
 * The Promise object represents the eventual completion (or failure)
 * of an asynchronous operation, and its resulting value.
 *
 * @func isPromise
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.1.0|v2.1.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link https://promisesaplus.com/|Promises/A+}, {@link RA.isThenable|isThenable}
 * @example
 *
 * RA.isPromise(null); // => false
 * RA.isPromise(undefined); // => false
 * RA.isPromise([]); // => false
 * RA.isPromise(Promise.resolve()); // => true
 * RA.isPromise(Promise.reject()); // => true
 * RA.isPromise({ then: () => 1 }); // => false
 */

var isPromise = Object(external_ramda_["both"])(src_isObj, Object(external_ramda_["pipe"])(external_ramda_["toString"], Object(external_ramda_["equals"])('[object Promise]')));
/* harmony default export */ var src_isPromise = (isPromise);
// CONCATENATED MODULE: ./src/isTrue.js

/**
 * Checks if input value is the Boolean primitive `true`. Will return false for Boolean objects
 * created using the `Boolean` function as a constructor.
 *
 * @func isTrue
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isFalse|isFalse}, {@link RA.isTruthy|isTruthy}, {@link RA.isFalsy|isFalsy}
 * @example
 *
 * RA.isTrue(true); // => true
 * RA.isTrue(Boolean(true)); // => true
 * RA.isTrue(false); // => false
 * RA.isTrue(1); // => false
 * RA.isTrue('true'); // => false
 * RA.isTrue(new Boolean(true)); // => false
 */

var isTrue = Object(external_ramda_["identical"])(true);
/* harmony default export */ var src_isTrue = (isTrue);
// CONCATENATED MODULE: ./src/isFalse.js

/**
 * Checks if input value is the Boolean primitive `false`. Will return false for all values created
 * using the `Boolean` function as a constructor.
 *
 * @func isFalse
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isTrue|isTrue}, {@link RA.isTruthy|isTruthy}, {@link RA.isFalsy|isFalsy}
 * @example
 *
 * RA.isFalse(false); // => true
 * RA.isFalse(Boolean(false)); // => true
 * RA.isFalse(true); // => false
 * RA.isFalse(0); // => false
 * RA.isFalse(''); // => false
 * RA.isFalse(null); // => false
 * RA.isFalse(undefined); // => false
 * RA.isFalse(NaN); // => false
 * RA.isFalse([]); // => false
 * RA.isFalse(new Boolean(false)); // => false
 */

var isFalse = Object(external_ramda_["identical"])(false);
/* harmony default export */ var src_isFalse = (isFalse);
// CONCATENATED MODULE: ./src/isTruthy.js
/**
 * In JavaScript, a `truthy` value is a value that is considered true
 * when evaluated in a Boolean context. All values are truthy unless
 * they are defined as falsy (i.e., except for `false`, `0`, `""`, `null`, `undefined`, and `NaN`).
 *
 * @func isTruthy
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.2.0|v2.2.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Truthy|truthy}, {@link RA.isFalsy|isFalsy}
 * @example
 *
 * RA.isTruthy({}); // => true
 * RA.isTruthy([]); // => true
 * RA.isTruthy(42); // => true
 * RA.isTruthy(3.14); // => true
 * RA.isTruthy('foo'); // => true
 * RA.isTruthy(new Date()); // => true
 * RA.isTruthy(Infinity); // => true
 */
var isTruthy = Boolean;
/* harmony default export */ var src_isTruthy = (isTruthy);
// CONCATENATED MODULE: ./src/isFalsy.js


/**
 * A falsy value is a value that translates to false when evaluated in a Boolean context.
 * Falsy values are `false`, `0`, `""`, `null`, `undefined`, and `NaN`.
 *
 * @func isFalsy
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.2.0|v2.2..0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Falsy|falsy}, {@link RA.isTruthy|isTruthy}
 * @example
 *
 * RA.isFalsy(false); // => true
 * RA.isFalsy(0); // => true
 * RA.isFalsy(''); // => true
 * RA.isFalsy(null); // => true
 * RA.isFalsy(undefined); // => true
 * RA.isFalsy(NaN); // => true
 */

var isFalsy = Object(external_ramda_["complement"])(src_isTruthy);
/* harmony default export */ var src_isFalsy = (isFalsy);
// CONCATENATED MODULE: ./src/isRegExp.js

/**
 * Checks if value is `RegExp` object.
 *
 * @func isRegExp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isNotRegExp|isNotRegExp}
 * @example
 *
 * RA.isRegExp(new RegExp()); //=> true
 * RA.isRegExp(/(?:)/); //=> true
 * RA.isRegExp(1); //=> false
 */

var isRegExp = Object(external_ramda_["pipe"])(external_ramda_["type"], Object(external_ramda_["identical"])('RegExp'));
/* harmony default export */ var src_isRegExp = (isRegExp);
// CONCATENATED MODULE: ./src/isNotRegExp.js


/**
 * Checks if value is complement of `RegExp` object.
 *
 * @func isNotRegExp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category Type
 * @sig * -> Boolean
 * @param {*} val The value to test
 * @return {boolean}
 * @see {@link RA.isRegExp|isRegExp}
 * @example
 *
 * RA.isNotRegExp(1); //=> true
 * RA.isNotRegExp(/(?:)/); //=> false
 * RA.isNotRegExp(new RegExp()); //=> false
 */

var isNotRegExp = Object(external_ramda_["complement"])(src_isRegExp);
/* harmony default export */ var src_isNotRegExp = (isNotRegExp);
// CONCATENATED MODULE: ./src/stubNull.js

/**
 * A function that returns `null`.
 *
 * @func stubNull
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.6.0|v1.6.0}
 * @category Function
 * @sig ... -> null
 * @return {null}
 * @example
 *
 * RA.stubNull(); //=> null
 * RA.stubNull(1, 2, 3); //=> null
 */

var stubNull = Object(external_ramda_["always"])(null);
/* harmony default export */ var src_stubNull = (stubNull);
// CONCATENATED MODULE: ./src/stubObj.js
/**
 * This function returns a new empty object.
 *
 * @func stubObj
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.1.0|v2.1.0}
 * @category Function
 * @sig ... -> Object
 * @aliases stubObject
 * @return {Object} Returns the new empty object.
 * @example
 *
 * RA.stubObj(); //=> {}
 * RA.stubObj(1, 2, 3); //=> {}
 */
var stubObj = function stubObj() {
  return {};
};

/* harmony default export */ var src_stubObj = (stubObj);
// CONCATENATED MODULE: ./src/stubString.js

/**
 * A function that returns empty string.
 *
 * @func stubString
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.1.0|v2.1.0}
 * @category Function
 * @sig ... -> String
 * @return {string} The empty string
 * @example
 *
 * RA.stubString(); //=> ''
 * RA.stubString(1, 2, 3); //=> ''
 */

var stubString = Object(external_ramda_["always"])('');
/* harmony default export */ var src_stubString = (stubString);
// CONCATENATED MODULE: ./src/stubArray.js
/**
 * A function that returns new empty array on every call.
 *
 * @func stubArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.1.0|v2.1.0}
 * @category Function
 * @sig ... -> Array
 * @return {Array} New empty array
 * @example
 *
 * RA.stubArray(); //=> []
 * RA.stubArray(1, 2, 3); //=> []
 */
var stubArray = function stubArray() {
  return [];
};

/* harmony default export */ var src_stubArray = (stubArray);
// CONCATENATED MODULE: ./src/noop.js


/**
 * A function that performs no operations.
 *
 * @func noop
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.0.0|v1.0.0}
 * @category Function
 * @sig ... -> undefined
 * @return {undefined}
 * @example
 *
 * RA.noop(); //=> undefined
 * RA.noop(1, 2, 3); //=> undefined
 */

var noop = Object(external_ramda_["always"])(src_stubUndefined());
/* harmony default export */ var src_noop = (noop);
// CONCATENATED MODULE: ./src/fantasy-land/mapping.js
var mapping = Object.freeze({
  equals: 'fantasy-land/equals',
  lte: 'fantasy-land/lte',
  compose: 'fantasy-land/compose',
  id: 'fantasy-land/id',
  concat: 'fantasy-land/concat',
  empty: 'fantasy-land/empty',
  map: 'fantasy-land/map',
  contramap: 'fantasy-land/contramap',
  ap: 'fantasy-land/ap',
  of: 'fantasy-land/of',
  alt: 'fantasy-land/alt',
  zero: 'fantasy-land/zero',
  reduce: 'fantasy-land/reduce',
  traverse: 'fantasy-land/traverse',
  chain: 'fantasy-land/chain',
  chainRec: 'fantasy-land/chainRec',
  extend: 'fantasy-land/extend',
  extract: 'fantasy-land/extract',
  bimap: 'fantasy-land/bimap',
  promap: 'fantasy-land/promap'
});
/* harmony default export */ var fantasy_land_mapping = (mapping);
// CONCATENATED MODULE: ./src/internal/ap.js



var isFunctor = Object(external_ramda_["either"])(Object(external_ramda_["pathSatisfies"])(src_isFunction, ['map']), Object(external_ramda_["pathSatisfies"])(src_isFunction, [fantasy_land_mapping.map]));
var isApply = Object(external_ramda_["both"])(isFunctor, Object(external_ramda_["either"])(Object(external_ramda_["pathSatisfies"])(src_isFunction, ['ap']), Object(external_ramda_["pathSatisfies"])(src_isFunction, [fantasy_land_mapping.ap])));
var ap = Object(external_ramda_["curryN"])(2, function (applyF, applyX) {
  // return original ramda `ap` if not Apply spec
  if (!isApply(applyF) || !isApply(applyX)) {
    return Object(external_ramda_["ap"])(applyF, applyX);
  }

  try {
    // new version of `ap` starting from ramda version > 0.23.0
    return applyF.ap(applyX);
  } catch (e) {
    // old version of `ap` till ramda version <= 0.23.0
    return applyX.ap(applyF);
  }
});
/* harmony default export */ var internal_ap = (ap);
// CONCATENATED MODULE: ./src/liftFN.js


/**
 * "lifts" a function to be the specified arity, so that it may "map over" objects that satisfy
 * the fantasy land Apply spec of algebraic structures.
 *
 * Lifting is specific for {@link https://github.com/scalaz/scalaz|scalaz} and {@link http://www.functionaljava.org/|functional java} implementations.
 * Old version of fantasy land spec were not compatible with this approach,
 * but as of fantasy land 1.0.0 Apply spec also adopted this approach.
 *
 * This function acts as interop for ramda <= 0.23.0 and {@link https://monet.github.io/monet.js/|monet.js}.
 *
 * More info {@link https://github.com/fantasyland/fantasy-land/issues/50|here}.
 *
 * @func liftFN
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.2.0|v1.2.0}
 * @category Function
 * @sig Apply a => Number -> (a... -> a) -> (a... -> a)
 * @param {Number} arity The arity of the lifter function
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function
 * @see {@link http://ramdajs.com/docs/#lift|R.lift}, {@link http://ramdajs.com/docs/#ap|R.ap}
 * @example
 *
 * const { Maybe } = require('monet');
 *
 * const add3 = (a, b, c) => a + b + c;
 * const madd3 = RA.liftFN(3, add3);
 *
 * madd3(Maybe.Some(10), Maybe.Some(15), Maybe.Some(17)); //=> Maybe.Some(42)
 * madd3(Maybe.Some(10), Maybe.Nothing(), Maybe.Some(17)); //=> Maybe.Nothing()
 */

var liftFN = Object(external_ramda_["curry"])(function (arity, fn) {
  var lifted = Object(external_ramda_["curryN"])(arity, fn);
  return Object(external_ramda_["curryN"])(arity, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var accumulator = Object(external_ramda_["map"])(lifted, Object(external_ramda_["head"])(args));
    var apps = Object(external_ramda_["slice"])(1, Infinity, args);
    return Object(external_ramda_["reduce"])(internal_ap, accumulator, apps);
  });
});
/* harmony default export */ var src_liftFN = (liftFN);
// CONCATENATED MODULE: ./src/liftF.js

/**
 * "lifts" a function to be the specified arity, so that it may "map over" objects that satisfy
 * the fantasy land Apply spec of algebraic structures.
 *
 * Lifting is specific for {@link https://github.com/scalaz/scalaz|scalaz} and {@link http://functionaljava.org/|function Java} implementations.
 * Old version of fantasy land spec were not compatible with this approach,
 * but as of fantasy land 1.0.0 Apply spec also adopted this approach.
 *
 * This function acts as interop for ramda <= 0.23.0 and {@link https://monet.github.io/monet.js/|monet.js}.
 *
 * More info {@link https://github.com/fantasyland/fantasy-land/issues/50|here}.
 *
 * @func liftF
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.2.0|v1.2.0}
 * @category Function
 * @sig Apply a => (a... -> a) -> (a... -> a)
 * @param {Function} fn The function to lift into higher context
 * @return {Function} The lifted function
 * @see {@link RA.liftFN|liftFN}
 * @example
 *
 * const { Maybe } = require('monet');
 *
 * const add3 = (a, b, c) => a + b + c;
 * const madd3 = RA.liftF(add3);
 *
 * madd3(Maybe.Some(10), Maybe.Some(15), Maybe.Some(17)); //=> Maybe.Some(42)
 * madd3(Maybe.Some(10), Maybe.Nothing(), Maybe.Some(17)); //=> Maybe.Nothing()
 */

var liftF_liftF = function liftF(fn) {
  return src_liftFN(fn.length, fn);
};

/* harmony default export */ var src_liftF = (liftF_liftF);
// CONCATENATED MODULE: ./src/cata.js


/**
 * The catamorphism is a way of folding a type into a value.
 *
 * **Either**
 *
 * If the either is right then the right function will be executed with
 * the `right` value and the value of the function returned. Otherwise the left function
 * will be called with the `left` value.
 *
 * **Maybe**
 *
 * If the maybe is Some than the right function will be executed with the `some` value and the value of the function
 * returned. Otherwise the left function with be called without an argument.
 *
 * **Result**
 *
 * If the result is Ok than the right function will be executed with the `Ok` value and the value of the function
 * returned. Otherwise the left function will be called with the `Error` value.
 *
 * **Validation**
 *
 * If the validation is Success than the right function will be executed with the `Success` value and the value of the function
 * returned. Otherwise the left function will be called with the `Failure` value.
 *
 * Supported monadic libraries: {@link https://monet.github.io/monet.js/|monet.js}, {@link https://folktale.origamitower.com/|folktale}, {@link https://github.com/ramda/ramda-fantasy|ramda-fantasy}
 *
 * @func cata
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.4.0|v1.4.0}
 * @category Function
 * @sig (a -> b) -> (a -> c) -> Cata a -> b | c
 * @param {Function} leftFn The left function that consumes the left value
 * @param {Function} rightFn The right function that consumes the right value
 * @param {Cata} catamorphicObj Either, Maybe or any other type with catamorphic capabilities (`cata` or `either` method)
 * @return {*}
 * @see {@link https://monet.github.io/monet.js/#cata|cata explained}
 * @example
 *
 * // Either
 * const eitherR = Either.Right(1);
 * const eitherL = Either.Left(2);
 *
 * RA.cata(identity, identity, eitherR); //=> 1
 * RA.cata(identity, identity, eitherL); //=> 2
 *
 * // Maybe
 * const maybeSome = Maybe.Some(1);
 * const maybeNothing = Maybe.Nothing();
 *
 * RA.cata(identity, identity, maybeSome); //=> 1
 * RA.cata(identity, identity, maybeNothing); //=> undefined
 */

var catamorphism = Object(external_ramda_["curry"])(function (leftFn, rightFn, catamorphicObj) {
  // folktale support
  if (src_isFunction(catamorphicObj.matchWith)) {
    return catamorphicObj.matchWith({
      // Result type
      Ok: function Ok(_ref) {
        var value = _ref.value;
        return rightFn(value);
      },
      Error: function Error(_ref2) {
        var value = _ref2.value;
        return leftFn(value);
      },
      // Maybe type
      Just: function Just(_ref3) {
        var value = _ref3.value;
        return rightFn(value);
      },
      Nothing: function Nothing() {
        return leftFn(undefined);
      },
      // Validation type
      Success: function Success(_ref4) {
        var value = _ref4.value;
        return rightFn(value);
      },
      Failure: function Failure(_ref5) {
        var value = _ref5.value;
        return leftFn(value);
      }
    });
  }

  if (src_isFunction(catamorphicObj.cata)) {
    return catamorphicObj.cata(leftFn, rightFn);
  }

  if (src_isFunction(catamorphicObj.getOrElse)) {
    var elseValue = "RA.cata".concat(Math.random());
    var value = catamorphicObj.getOrElse(elseValue);
    return value === elseValue ? leftFn() : rightFn(value);
  }

  return catamorphicObj.either(leftFn, rightFn);
});
/* harmony default export */ var cata = (catamorphism);
// CONCATENATED MODULE: ./src/weave.js

/**
 * Weaves a configuration into function returning the runnable monad like `Reader` or `Free`.
 * This allows us to pre-bind the configuration in advance and use the weaved function
 * without need to explicitly pass the configuration on every call.
 *
 * @func weave
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.7.0|v1.7.0}
 * @category Function
 * @sig (*... -> *) -> * -> (*... -> *)
 * @param {Function} fn The function to weave
 * @param {*} config The configuration to weave into fn
 * @return {Function} Auto-curried weaved function
 * @example
 *
 * const { Reader: reader } = require('monet');
 *
 * const log = value => reader(
 *   config => config.log(value)
 * );
 *
 * // no weaving
 * log('test').run(console); //=> prints 'test'
 *
 * // weaving
 * const wlog = RA.weave(log, console);
 * wlog('test'); //=> prints 'test'
 */

var weave = Object(external_ramda_["curryN"])(2, function (fn, config) {
  return Object(external_ramda_["curryN"])(fn.length, function () {
    return fn.apply(void 0, arguments).run(config);
  });
});
/* harmony default export */ var src_weave = (weave);
// CONCATENATED MODULE: ./src/weaveLazy.js

/**
 * Weaves a configuration into function returning the runnable monad like `Reader` or `Free`.
 * This allows us to pre-bind the configuration in advance and use the weaved function
 * without need to explicitly pass the configuration on every call.
 *
 * @func weaveLazy
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.10.0|v1.10.0}
 * @category Function
 * @sig (*... -> *) -> (* -> *) -> (*... -> *)
 * @param {Function} fn The function to weave
 * @param {Function} configAccessor The function that returns the configuration object
 * @return {Function} Auto-curried weaved function
 * @example
 *
 * const { Reader: reader } = require('monet');
 *
 * const log = value => reader(
 *   config => config.log(value)
 * );
 *
 * const consoleAccessor = R.always(console);
 *
 * // no weaving
 * log('test').run(console); //=> prints 'test'
 *
 * // weaving
 * const wlog = RA.weaveLazy(log, consoleAccessor);
 * wlog('test'); //=> prints 'test'
 */

var weaveLazy = Object(external_ramda_["curryN"])(2, function (fn, configAccessor) {
  return Object(external_ramda_["curryN"])(fn.length, function () {
    return fn.apply(void 0, arguments).run(configAccessor());
  });
});
/* harmony default export */ var src_weaveLazy = (weaveLazy);
// CONCATENATED MODULE: ./src/curryRightN.js

/**
 * Returns a curried equivalent of the provided function, with the specified arity.
 * This function is like curryN, except that the provided arguments order is reversed.
 *
 * @func curryRightN
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.12.0|v1.12.0}
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function
 * @param {Function} fn The function to curry
 * @return {Function}  A new, curried function
 * @see {@link http://ramdajs.com/docs/#curryN|R.curryN}, {@link RA.curryRight|curryRight}
 * @example
 *
 * const concatStrings = (a, b, c) => a + b + c;
 * const concatStringsCurried = RA.curryRightN(3, concatStrings);
 *
 * concatStringCurried('a')('b')('c'); // => 'cba'
 */

var curryRightN = Object(external_ramda_["curryN"])(2, function (arity, fn) {
  return Object(external_ramda_["curryN"])(arity, function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return fn.apply(this, Object(external_ramda_["reverse"])(args));
  });
});
/* harmony default export */ var src_curryRightN = (curryRightN);
// CONCATENATED MODULE: ./src/curryRight.js


/**
 * Returns a curried equivalent of the provided function.
 * This function is like curry, except that the provided arguments order is reversed.
 *
 * @func curryRight
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.12.0|v1.12.0}
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry
 * @return {Function}  A new, curried function
 * @see {@link http://ramdajs.com/docs/#curry|R.curry}, {@link RA.curryRightN|curryRightN}
 * @example
 *
 * const concatStrings = (a, b, c) => a + b + c;
 * const concatStringsCurried = RA.curryRight(concatStrings);
 *
 * concatStringCurried('a')('b')('c'); // => 'cba'
 */

var curryRight = Object(external_ramda_["converge"])(src_curryRightN, [external_ramda_["length"], external_ramda_["identity"]]);
/* harmony default export */ var src_curryRight = (curryRight);
// CONCATENATED MODULE: ./src/allP.js


/**
 * Composable shortcut for `Promise.all`.
 *
 * The `allP` method returns a single Promise that resolves when all of the promises
 * in the iterable argument have resolved or when the iterable argument contains no promises.
 * It rejects with the reason of the first promise that rejects.
 *
 * @func allP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Function
 * @sig [Promise a] -> Promise [a]
 * @param {Iterable.<*>} iterable An iterable object such as an Array or String
 * @return {Promise} An already resolved Promise if the iterable passed is empty. An asynchronously resolved Promise if the iterable passed contains no promises. Note, Google Chrome 58 returns an already resolved promise in this case. A pending Promise in all other cases. This returned promise is then resolved/rejected asynchronously (as soon as the stack is empty) when all the promises in the given iterable have resolved, or if any of the promises reject. See the example about "Asynchronicity or synchronicity of allP" below.
 * @see {@link RA.resolveP|resolveP}, {@link RA.rejectP|rejectP}
 * @example
 *
 * RA.allP([1, 2]); //=> Promise([1, 2])
 * RA.allP([1, Promise.resolve(2)]); //=> Promise([1, 2])
 * RA.allP([Promise.resolve(1), Promise.resolve(2)]); //=> Promise([1, 2])
 * RA.allP([1, Promise.reject(2)]); //=> Promise(2)
 */

var allP = _curry1_default()(Object(external_ramda_["bind"])(Promise.all, Promise));
/* harmony default export */ var src_allP = (allP);
// CONCATENATED MODULE: ./src/resolveP.js

/* eslint-disable max-len */

/**
 * Composable shortcut for `Promise.resolve`.
 *
 * Returns a Promise object that is resolved with the given value.
 * If the value is a thenable (i.e. has a "then" method), the returned promise will
 * "follow" that thenable, adopting its eventual state.
 *
 * @func resolveP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.16.0|v1.16.0}
 * @category Function
 * @sig a -> Promise a
 * @param {*} [value=undefined] Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve
 * @return {Promise} A Promise that is resolved with the given value, or the promise passed as value, if the value was a promise object
 * @see {@link RA.rejectP|rejectP}
 * @example
 *
 * RA.resolveP(); //=> Promise(undefined)
 * RA.resolveP('a'); //=> Promise('a')
 * RA.resolveP([1, 2, 3]); //=> Promise([1, 2, 3])
 */

/* eslint-enable max-len */

var resolveP = Object(external_ramda_["bind"])(Promise.resolve, Promise);
/* harmony default export */ var src_resolveP = (resolveP);
// CONCATENATED MODULE: ./src/rejectP.js

/**
 * Composable shortcut for `Promise.reject`.
 *
 * Returns a Promise object that is rejected with the given reason.
 *
 * @func rejectP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.16.0|v1.16.0}
 * @category Function
 * @sig a -> Promise a
 * @param {*} [reason=undefined] Reason why this Promise rejected
 * @return {Promise} A Promise that is rejected with the given reason
 * @see {@link RA.resolveP|resolveP}
 * @example
 *
 * RA.rejectP(); //=> Promise(undefined)
 * RA.rejectP('a'); //=> Promise('a')
 * RA.rejectP([1, 2, 3]); //=> Promise([1, 2, 3])
 */

var rejectP = Object(external_ramda_["bind"])(Promise.reject, Promise);
/* harmony default export */ var src_rejectP = (rejectP);
// CONCATENATED MODULE: ./src/thenP.js

/**
 * Composable shortcut for `Promise.then`.
 * The thenP function returns a Promise. It takes two arguments: a callback function for the success of the Promise
 * and the promise instance itself.
 *
 * @func thenP
 * @memberOf RA
 * @aliases then
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @deprecated since v2.12.0; available in ramda@0.26.0 as R.then
 * @category Function
 * @sig (a -> Promise b | b) -> Promise b
 * @param {Function} onFulfilled A Function called if the Promise is fulfilled. This function has one argument, the fulfillment value
 * @param {Promise} promise Any Promise or Thenable object
 * @return {Promise} A Promise in the pending status

 * @see {@link RA.resolveP|resolveP}, {@link RA.rejectP|rejectP}, {@link RA.allP|allP}
 * @example
 *
 * const promise = Promise.resolve(1);
 * const add1 = v => v + 1;
 *
 * RA.thenP(add1, promise); // => Promise(2)
 */

var thenP = Object(external_ramda_["invoker"])(1, 'then');
/* harmony default export */ var src_thenP = (thenP);
// CONCATENATED MODULE: ./src/internal/polyfills/Promise.allSettled.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }





var onFulfill = function onFulfill(value) {
  return {
    status: 'fulfilled',
    value: value
  };
};

var onReject = function onReject(reason) {
  return {
    status: 'rejected',
    reason: reason
  };
};

var Promise_allSettled_allSettledPolyfill = function allSettledPolyfill(iterable) {
  var array = Object(external_ramda_["map"])(function (p) {
    return src_resolveP(p).then(onFulfill)["catch"](onReject);
  }, _toConsumableArray(iterable));
  return src_allP(array);
};

/* harmony default export */ var Promise_allSettled = (Promise_allSettled_allSettledPolyfill);
// CONCATENATED MODULE: ./src/allSettledP.js




var allSettledPPolyfill = _curry1_default()(Promise_allSettled);
/**
 * Returns a promise that is fulfilled with an array of promise state snapshots,
 * but only after all the original promises have settled, i.e. become either fulfilled or rejected.
 * We say that a promise is settled if it is not pending, i.e. if it is either fulfilled or rejected.
 *
 * @func allSettledP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.18.0|v2.18.0}
 * @category Function
 * @typedef Settlement = { status: String, value: * }
 * @sig [Promise a] -> Promise [Settlement a]
 * @param {Iterable.<*>} iterable An iterable object such as an Array or String
 * @return {Promise} Returns a promise that is fulfilled with an array of promise state snapshots
 * @see {@link RA.allP|allP}
 * @example
 *
 * RA.allSettledP([
 *   Promise.resolve(1),
 *   2,
 *   Promise.reject(3),
 * ]); //=> Promise([{ status: 'fulfilled', value: 1 }, { status: 'fulfilled', value: 2 }, { status: 'rejected', reason: 3 }])
 */

var allSettledP = src_isFunction(Promise.allSettled) ? _curry1_default()(Object(external_ramda_["bind"])(Promise.allSettled, Promise)) : allSettledPPolyfill;
/* harmony default export */ var src_allSettledP = (allSettledP);
// CONCATENATED MODULE: ./src/Y.js
/**
 * Y-combinator
 *
 * The Y combinator is an interesting function which only works with functional languages,
 * showing how recursion can still be done even without any variable or function declarations,
 * only functions and parameters
 *
 * @func Y
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Function
 * @sig (a, ... -> b -> b) -> (a, ... -> b)
 * @param {Function} le Recursive function maker
 * @return {Function}
 * @see {@link http://kestas.kuliukas.com/YCombinatorExplained/|Y combinator explained}
 * @example
 *
 * const makeFact = givenFact => (n) => {
 *   if (n < 2) { return 1 }
 *   return n * givenFact(n - 1);
 * };
 *
 * const factorial = RA.Y(makeFact);
 *
 * factorial(5); //=> 120
 */
var Y = function Y(le) {
  return function (f) {
    return f(f);
  }(function (g) {
    return le(function (x) {
      return g(g)(x);
    });
  });
};

/* harmony default export */ var src_Y = (Y);
// CONCATENATED MODULE: ./src/seq.js

/* eslint-disable max-len */

/**
 * Runs the given list of functions in order with the supplied object, then returns the object.
 * Also known as the normal order sequencing combinator.
 *
 * Acts as a transducer if a transformer is given as second parameter.
 *
 * @func seq
 * @aliases sequencing
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Function
 * @sig [(a -> *), (a -> *), ...] -> a -> a
 * @param {Array} fns The list of functions to call in order with `x` whose return values will be thrown away
 * @param {*} x
 * @return {*} `x`
 * @see {@link http://ramdajs.com/docs/#tap|R.tap}, {@link http://www.cs.rpi.edu/academics/courses/spring11/proglang/handouts/lambda-calculus-chapter.pdf|sequencing combinator explained}
 * @example
 *
 * RA.seq([console.info, console.log])('foo'); //=> prints 'foo' via info then log
 *
 * // usage in composition
 * R.pipe(
 *   R.concat('prefix '),
 *   RA.seq([
 *     console.info, //=> prints 'prefix test'
 *     console.log //=> prints 'prefix test'
 *   ]),
 *   R.toUpper
 * )('test'); //=> 'PREFIX TEST'
 */

/* eslint-enable max-len */

var seq = Object(external_ramda_["curry"])(function (fns, x) {
  return Object(external_ramda_["tap"])(function (tx) {
    return Object(external_ramda_["map"])(function (fn) {
      return fn(tx);
    })(fns);
  })(x);
});
/* harmony default export */ var src_seq = (seq);
// CONCATENATED MODULE: ./src/dispatch.js
function dispatch_toConsumableArray(arr) { return dispatch_arrayWithoutHoles(arr) || dispatch_iterableToArray(arr) || dispatch_nonIterableSpread(); }

function dispatch_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function dispatch_iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function dispatch_arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }


/**
 * Can be used as a way to compose multiple invokers together to form polymorphic functions,
 * or functions that exhibit different behaviors based on their argument(s).
 * Consumes dispatching functions and keep trying to invoke each in turn, until a non-nil value is returned.
 *
 * Accepts a list of dispatching functions and returns a new function.
 * When invoked, this new function is applied to some arguments,
 * each dispatching function is applied to those same arguments until one of the
 * dispatching functions returns a non-nil value.
 *
 * @func dispatch
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Function
 * @sig [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> x1 | x2 | ...
 * @param {!Array} functions A list of functions
 * @return {*|undefined} Returns the first not-nil value, or undefined if either an empty list is provided or none of the dispatching functions returns a non-nil value
 * @see {@link RA.isNotNil}
 * @example
 *
 * // returns first non-nil value
 * const stubNil = () => null;
 * const stubUndefined = () => undefined;
 * const addOne = v => v + 1;
 * const addTwo = v => v + 2;
 *
 * RA.dispatch([stubNil, stubUndefined, addOne, addTwo])(1); //=> 2
 *
 * // acts as a switch
 * const fnSwitch = RA.dispatch([
 *   R.ifElse(RA.isString, s => `${s}-join`, RA.stubUndefined),
 *   R.ifElse(RA.isNumber, n => n + 1, RA.stubUndefined),
 *   R.ifElse(RA.isDate, R.T, RA.stubUndefined),
 * ]);
 * fnSwitch(1); //=> 2
 */




var byArity = Object(external_ramda_["comparator"])(function (a, b) {
  return a.length > b.length;
});
var getMaxArity = Object(external_ramda_["pipe"])(Object(external_ramda_["sort"])(byArity), external_ramda_["head"], Object(external_ramda_["prop"])('length'));
var iteratorFn = Object(external_ramda_["curry"])(function (args, accumulator, fn) {
  var result = fn.apply(void 0, dispatch_toConsumableArray(args));
  return src_isNotNil(result) ? Object(external_ramda_["reduced"])(result) : accumulator;
});

var dispatch_dispatch = function dispatch(functions) {
  var arity = getMaxArity(functions);
  return Object(external_ramda_["curryN"])(arity, function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Object(external_ramda_["reduce"])(iteratorFn(args), undefined, functions);
  });
};

/* harmony default export */ var src_dispatch = (Object(external_ramda_["ifElse"])(src_isNonEmptyArray, dispatch_dispatch, src_stubUndefined));
// CONCATENATED MODULE: ./src/async.js




/**
 * Takes a generator function and returns an async function.
 * The async function returned is a curried function whose arity matches that of the generator function.
 *
 * Note: This function is handy for environments that does support generators but doesn't support async/await.
 *
 * @func async
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.16.0|v2.16.0}
 * @category Function
 * @sig Promise c => (a, b, ...) -> a -> b -> ... -> c
 * @param {Function} generatorFn The generator function
 * @return {Function} Curried async function
 * @see {@link https://www.promisejs.org/generators/}
 * @example
 *
 * const asyncFn = RA.async(function* generator(val1, val2) {
 *   const a = yield Promise.resolve(val1);
 *   const b = yield Promise.resolve(val2);
 *
 *   return a + b;
 * });
 *
 * asyncFn(1, 2); //=> Promise(3)
 *
 */

var async_async = _curry1_default()(function (generatorFn) {
  function asyncWrapper() {
    var iterator = Object(external_ramda_["bind"])(generatorFn, this).apply(void 0, arguments);

    var handle = function handle(result) {
      var resolved = src_resolveP(result.value);
      return result.done ? resolved : resolved.then(function (value) {
        return handle(iterator.next(value));
      }, function (error) {
        return handle(iterator["throw"](error));
      });
    };

    try {
      return handle(iterator.next());
    } catch (error) {
      return src_rejectP(error);
    }
  }

  if (generatorFn.length > 0) {
    return Object(external_ramda_["curryN"])(generatorFn.length, asyncWrapper);
  }

  return asyncWrapper;
});
/* harmony default export */ var src_async = (async_async);
// CONCATENATED MODULE: ./src/mapIndexed.js

/**
 * {@link http://ramdajs.com/docs/#map|R.map} function that more closely resembles Array.prototype.map.
 * It takes two new parameters to its callback function: the current index, and the entire list.
 *
 * `mapIndexed` implementation is simple : `
 * const mapIndexed = R.addIndex(R.map);
 * `
 * @func mapIndexed
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category List
 * @typedef Idx = Number
 * @sig Functor f => ((a, Idx, f a) => b) => f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`
 * @param {Array} list The list to be iterated over
 * @return {Array} The new list
 * @see {@link http://ramdajs.com/docs/#addIndex|R.addIndex}, {@link http://ramdajs.com/docs/#map|R.map}
 * @example
 *
 * RA.mapIndexed((val, idx, list) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
 * //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
 */

var mapIndexed = Object(external_ramda_["addIndex"])(external_ramda_["map"]);
/* harmony default export */ var src_mapIndexed = (mapIndexed);
// CONCATENATED MODULE: ./src/reduceIndexed.js

/**
 * {@link http://ramdajs.com/docs/#reduce|R.reduce} function that more closely resembles Array.prototype.reduce.
 * It takes two new parameters to its callback function: the current index, and the entire list.
 *
 * `reduceIndexed` implementation is simple : `
 * const reduceIndexed = R.addIndex(R.reduce);
 * `
 * @func reduceIndexed
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category List
 * @typedef Idx = Number
 * @sig ((a, b, Idx, [b]) => a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives four values,
 * the accumulator, the current element from the array, index and the entire list
 * @param {*} acc The accumulator value
 * @param {Array} list The list to iterate over
 * @return {*} The final, accumulated value
 * @see {@link http://ramdajs.com/docs/#addIndex|R.addIndex}, {@link http://ramdajs.com/docs/#reduce|R.reduce}
 * @example
 *
 * const initialList = ['f', 'o', 'o', 'b', 'a', 'r'];
 *
 * reduceIndexed((acc, val, idx, list) => acc + '-' + val + idx, '', initialList);
 * //=> "-f0-o1-o2-b3-a4-r5"
 */

var reduceIndexed = Object(external_ramda_["addIndex"])(external_ramda_["reduce"]);
/* harmony default export */ var src_reduceIndexed = (reduceIndexed);
// CONCATENATED MODULE: ./src/pickIndexes.js
 // helpers

var filterIndexed = Object(external_ramda_["addIndex"])(external_ramda_["filter"]);
var containsIndex = Object(external_ramda_["curry"])(function (indexes, val, index) {
  return Object(external_ramda_["contains"])(index, indexes);
});
/**
 * Picks values from list by indexes.
 *
 * @func pickIndexes
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.1.0|v1.1.0}
 * @category List
 * @sig  [Number] -> [a] -> [a]
 * @param {Array} indexes The indexes to pick
 * @param {Array} list The list to pick values from
 * @return {Array} New array containing only values at `indexes`
 * @see {@link http://ramdajs.com/docs/#pick|R.pick}, {@link RA.omitIndexes|omitIndexes}
 * @example
 *
 * RA.pickIndexes([0, 2], ['a', 'b', 'c']); //=> ['a', 'c']
 */

var pickIndexes = Object(external_ramda_["curry"])(function (indexes, list) {
  return filterIndexed(containsIndex(indexes), list);
});
/* harmony default export */ var src_pickIndexes = (pickIndexes);
// CONCATENATED MODULE: ./src/list.js

/**
 * Creates a list from arguments.
 *
 * @func list
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.1.0|v1.1.0}
 * @category List
 * @sig  a... -> [a...]
 * @param {...*} items The items of the feature list
 * @return {Array} New list created from items
 * @see {@link https://github.com/ramda/ramda/wiki/Cookbook#create-a-list-function|Ramda Cookbook}
 * @example
 *
 * RA.list('a', 'b', 'c'); //=> ['a', 'b', 'c']
 */

var list_list = Object(external_ramda_["unapply"])(external_ramda_["identity"]);
/* harmony default export */ var src_list = (list_list);
// CONCATENATED MODULE: ./src/ensureArray.js


/**
 * Returns a singleton array containing the value provided.
 * If value is already an array, it is returned as is.
 *
 * @func ensureArray
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category List
 * @sig a | [a] -> [a]
 * @param {*|Array} val the value ensure as Array
 * @return {Array}
 * @see {@link http://ramdajs.com/docs/#of|R.of}
 * @example
 *
 * RA.ensureArray(42); //=> [42]
 * RA.ensureArray([42]); //=> [42]
 */

var ensureArray = Object(external_ramda_["when"])(src_isNotArray, external_ramda_["of"]);
/* harmony default export */ var src_ensureArray = (ensureArray);
// CONCATENATED MODULE: ./src/concatAll.js


var leftIdentitySemigroup = {
  concat: external_ramda_["identity"]
};
/**
 * Returns the result of concatenating the given lists or strings.
 * Note: RA.concatAll expects all elements to be of the same type. It will throw an error if you concat an Array with a non-Array value.
 * Dispatches to the concat method of the preceding element, if present. Can also concatenate multiple elements of a [fantasy-land compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
 * Returns undefined if empty array was passed.
 *
 * @func concatAll
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category List
 * @sig [[a]] -> [a] | Undefined
 * @sig [String] -> String | Undefined
 * @sig Semigroup s => Foldable s f => f -> s | Undefined
 * @param {Array.<Array|string>} list List containing elements that will be concatenated
 * @return {Array|string|undefined} Concatenated elements
 * @see {@link http://ramdajs.com/docs/#concat|R.concat}, {@link RA.concatRight|concatRight}, {@link http://ramdajs.com/docs/#unnest|R.unnest}, {@link http://ramdajs.com/docs/#join|R.join}
 * @example
 *
 * concatAll([[1], [2], [3]]); //=> [1, 2, 3]
 * concatAll(['1', '2', '3']); //=> '123'
 * concatAll([]); //=> undefined;
 */

var concatAll = Object(external_ramda_["pipe"])(Object(external_ramda_["reduce"])(external_ramda_["concat"], leftIdentitySemigroup), Object(external_ramda_["when"])(Object(external_ramda_["identical"])(leftIdentitySemigroup), src_stubUndefined));
/* harmony default export */ var src_concatAll = (concatAll);
// CONCATENATED MODULE: ./src/concatRight.js

/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: R.concat expects both arguments to be of the same type, unlike
 * the native Array.prototype.concat method.
 * It will throw an error if you concat an Array with a non-Array value.
 * Dispatches to the concat method of the second argument, if present.
 *
 * @func concatRight
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.11.0|v1.11.0}
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} firstList The first list
 * @param {Array|String} secondList The second list
 * @return {Array|String} A list consisting of the elements of `secondList`
 * followed by the elements of `firstList`.
 * @see {@link http://ramdajs.com/docs/#concat|R.concat}
 * @example
 *
 * RA.concatRight('ABC', 'DEF'); //=> 'DEFABC'
 * RA.concatRight([4, 5, 6], [1, 2, 3]); //=> [1, 2, 3, 4, 5, 6]
 * RA.concatRight([], []); //=> []
 */

var concatRight = Object(external_ramda_["flip"])(external_ramda_["concat"]);
/* harmony default export */ var src_concatRight = (concatRight);
// CONCATENATED MODULE: ./src/reduceP.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





/* eslint-disable max-len */

/**
 * Given an `Iterable`(arrays are `Iterable`), or a promise of an `Iterable`,
 * which produces promises (or a mix of promises and values),
 * iterate over all the values in the `Iterable` into an array and
 * reduce the array to a value using the given iterator function.
 *
 * If the iterator function returns a promise, then the result of the promise is awaited,
 * before continuing with next iteration. If any promise in the array is rejected or a promise
 * returned by the iterator function is rejected, the result is rejected as well.
 *
 * If `initialValue` is `undefined` (or a promise that resolves to `undefined`) and
 * the `Iterable` contains only 1 item, the callback will not be called and
 * the `Iterable's` single item is returned. If the `Iterable` is empty, the callback
 * will not be called and `initialValue` is returned (which may be undefined).
 *
 * This function is basically equivalent to {@link http://bluebirdjs.com/docs/api/promise.reduce.html|bluebird.reduce}.
 *
 * @func reduceP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|v1.13.0}
 * @category List
 * @typedef MaybePromise = Promise.<*> | *
 * @sig ((Promise a, MaybePromise b) -> Promise a) -> MaybePromise a -> MaybePromise [MaybePromise b] -> Promise a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the current element from the list
 * @param {*|Promise.<*>} acc The accumulator value
 * @param {Array.<*>|Promise.<Array<*|Promise.<*>>>} list The list to iterate over
 * @return {Promise} The final, accumulated value
 * @see {@link http://ramdajs.com/docs/#reduce|R.reduce}, {@link RA.reduceRightP|reduceRightP}, {@link http://bluebirdjs.com/docs/api/promise.reduce.html|bluebird.reduce}
 * @example
 *
 * RA.reduceP(
 *   (total, fileName) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   ['file1.txt', 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceP(
 *   (total, fileName) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   Promise.resolve(0),
 *   ['file1.txt', 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceP(
 *   (total, fileName) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   [Promise.resolve('file1.txt'), 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceP(
 *   (total, fileName) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   Promise.resolve([Promise.resolve('file1.txt'), 'file2.txt', 'file3.txt'])
 * ); // => Promise(10)
 *
 */

/* esline-enable max-len */

var reduceP = Object(external_ramda_["curryN"])(3, function (fn, acc, list) {
  return src_resolveP(list).then(function (iterable) {
    var listLength = Object(external_ramda_["length"])(iterable);

    if (listLength === 0) {
      return acc;
    }

    var reducer = Object(external_ramda_["reduce"])(function (accP, currentValueP) {
      return accP.then(function (previousValue) {
        return src_allP([previousValue, currentValueP]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            previousValue = _ref2[0],
            currentValue = _ref2[1];

        if (src_isUndefined(previousValue) && listLength === 1) {
          return currentValue;
        }

        return fn(previousValue, currentValue);
      });
    });
    return reducer(src_resolveP(acc), iterable);
  });
});
/* harmony default export */ var src_reduceP = (reduceP);
// CONCATENATED MODULE: ./src/reduceRightP.js
function reduceRightP_slicedToArray(arr, i) { return reduceRightP_arrayWithHoles(arr) || reduceRightP_iterableToArrayLimit(arr, i) || reduceRightP_nonIterableRest(); }

function reduceRightP_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function reduceRightP_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function reduceRightP_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




 // in older ramda versions the order of the arguments is flipped

var flipArgs = Object(external_ramda_["pipe"])(Object(external_ramda_["reduceRight"])(external_ramda_["concat"], ''), Object(external_ramda_["equals"])('ba'))(['a', 'b']);
/* eslint-disable max-len */

/**
 * Given an `Iterable`(arrays are `Iterable`), or a promise of an `Iterable`,
 * which produces promises (or a mix of promises and values),
 * iterate over all the values in the `Iterable` into an array and
 * reduce the array to a value using the given iterator function.
 *
 * Similar to {@link RA.reduceP|reduceP} except moves through the input list from the right to the left.
 * The iterator function receives two values: (value, acc),
 * while the arguments' order of reduceP's iterator function is (acc, value).
 *
 * @func reduceRightP
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|v1.13.0}
 * @category List
 * @typedef MaybePromise = Promise.<*> | *
 * @sig ((MaybePromise b, Promise a) -> Promise a) -> MaybePromise a -> MaybePromise [MaybePromise b] -> Promise a
 * @param {Function} fn The iterator function. Receives two values, the current element from the list and the accumulator
 * @param {*|Promise.<*>} acc The accumulator value
 * @param {Array.<*>|Promise.<Array<*|Promise.<*>>>} list The list to iterate over
 * @return {Promise} The final, accumulated value
 * @see {@link RA.reduceP|reduceP}, {@link http://bluebirdjs.com/docs/api/promise.reduce.html|bluebird.reduce}
 * @example
 *
 * RA.reduceRightP(
 *   (fileName, total) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   ['file1.txt', 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceRightP(
 *   (fileName, total) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   Promise.resolve(0),
 *   ['file1.txt', 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceRightP(
 *   (fileName, total) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   [Promise.resolve('file1.txt'), 'file2.txt', 'file3.txt']
 * ); // => Promise(10)
 *
 * RA.reduceRightP(
 *   (fileName, total) => fs
 *     .readFileAsync(fileName, 'utf8')
 *     .then(contents => total + parseInt(contents, 10)),
 *   0,
 *   Promise.resolve([Promise.resolve('file1.txt'), 'file2.txt', 'file3.txt'])
 * ); // => Promise(10)
 *
 */

/* esline-enable max-len */

var reduceRightP = Object(external_ramda_["curryN"])(3, function (fn, acc, list) {
  return src_resolveP(list).then(function (iterable) {
    var listLength = Object(external_ramda_["length"])(iterable);

    if (listLength === 0) {
      return acc;
    }

    var reducer = Object(external_ramda_["reduceRight"])(function (arg1, arg2) {
      var accP;
      var currentValueP;

      if (flipArgs) {
        accP = arg1;
        currentValueP = arg2;
      } else {
        accP = arg2;
        currentValueP = arg1;
      }

      return accP.then(function (previousValue) {
        return src_allP([previousValue, currentValueP]);
      }).then(function (_ref) {
        var _ref2 = reduceRightP_slicedToArray(_ref, 2),
            previousValue = _ref2[0],
            currentValue = _ref2[1];

        if (src_isUndefined(previousValue) && listLength === 1) {
          return currentValue;
        }

        return fn(currentValue, previousValue);
      });
    });
    return reducer(src_resolveP(acc), iterable);
  });
});
/* harmony default export */ var src_reduceRightP = (reduceRightP);
// CONCATENATED MODULE: ./src/sliceFrom.js

/**
 * Returns the elements of the given list or string (or object with a slice method)
 * from fromIndex (inclusive).
 * Dispatches to the slice method of the second argument, if present.
 *
 * @func sliceFrom
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.16.0|v1.16.0}
 * @category List
 * @sig  Number -> [a] -> [a]
 * @param {number} fromIndex The start index (inclusive)
 * @param {Array|string} list The list or string to slice
 * @return {Array|string} The sliced list or string
 * @see {@link http://ramdajs.com/docs/#slice|R.slice}, {@link RA.sliceTo|sliceTo}
 * @example
 *
 * RA.sliceFrom(1, [1, 2, 3]); //=> [2, 3]
 */

var sliceFrom = Object(external_ramda_["slice"])(external_ramda_["__"], Infinity);
/* harmony default export */ var src_sliceFrom = (sliceFrom);
// CONCATENATED MODULE: ./src/sliceTo.js

/**
 * Returns the elements of the given list or string (or object with a slice method)
 * to toIndex (exclusive).
 * Dispatches to the slice method of the second argument, if present.
 *
 * @func sliceTo
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.16.0|v1.16.0}
 * @category List
 * @sig  Number -> [a] -> [a]
 * @param {number} toIndex The end index (exclusive)
 * @param {Array|string} list The list or string to slice
 * @return {Array|string} The sliced list or string
 * @see {@link http://ramdajs.com/docs/#slice|R.slice}, {@link RA.sliceFrom|sliceFrom}
 * @example
 *
 * RA.sliceTo(2, [1, 2, 3]); //=> [1, 2]
 */

var sliceTo = Object(external_ramda_["slice"])(0);
/* harmony default export */ var src_sliceTo = (sliceTo);
// CONCATENATED MODULE: ./src/omitIndexes.js
 // helpers

var rejectIndexed = Object(external_ramda_["addIndex"])(external_ramda_["reject"]);
var omitIndexes_containsIndex = Object(external_ramda_["curry"])(function (indexes, val, index) {
  return Object(external_ramda_["contains"])(index, indexes);
});
/**
 * Returns a partial copy of an array omitting the indexes specified.
 *
 * @func omitIndexes
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category List
 * @sig [Int] -> [a] -> [a]
 * @see {@link http://ramdajs.com/docs/#omit|R.omit}, {@link RA.pickIndexes|pickIndexes}
 * @param {!Array} indexes The array of indexes to omit from the new array
 * @param {!Array} list The array to copy from
 * @return {!Array} The new array with omitted indexes
 * @example
 *
 * RA.omitIndexes([-1, 1, 3], ['a', 'b', 'c', 'd']); //=> ['a', 'c']
 */

var omitIndexes = Object(external_ramda_["curry"])(function (indexes, list) {
  return rejectIndexed(omitIndexes_containsIndex(indexes), list);
});
/* harmony default export */ var src_omitIndexes = (omitIndexes);
// CONCATENATED MODULE: ./src/compact.js


/**
 * Creates an array with all falsy values removed.
 * The values false, null, 0, "", undefined, and NaN are falsy.
 *
 * @func compact
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category List
 * @sig Filterable f => f a -> f a
 * @param {Array} list The array to compact
 * @return {Array} Returns the new array of filtered values
 * @see {@link RA.isFalsy|isFalsy}
 * @example
 *
 * RA.compact([0, 1, false, 2, '', 3]); //=> [1, 2, 3]
 */

var compact = Object(external_ramda_["reject"])(src_isFalsy);
/* harmony default export */ var src_compact = (compact);
// CONCATENATED MODULE: ./src/appendFlipped.js

/**
 * Returns a new list containing the contents of the given list, followed by the given element.
 * Like {@link http://ramdajs.com/docs/#append|R.append} but with argument order reversed.
 *
 * @func appendFlipped
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category List
 * @sig [a] -> a -> [a]
 * @param {Array} list The list of elements to add a new item to
 * @param {*} el The element to add to the end of the new list
 * @return {Array} A new list containing the elements of the old list followed by `el`
 * @see {@link http://ramdajs.com/docs/#append|R.append}
 * @example
 *
 * RA.appendFlipped(['write', 'more'], 'tests'); //=> ['write', 'more', 'tests']
 * RA.appendFlipped([], 'tests'); //=> ['tests']
 * RA.appendFlipped(['write', 'more'], ['tests']); //=> ['write', 'more', ['tests']]
 */

var appendFlipped = Object(external_ramda_["flip"])(external_ramda_["append"]);
/* harmony default export */ var src_appendFlipped = (appendFlipped);
// CONCATENATED MODULE: ./src/contained.js

/**
 * Returns true if the specified value is equal, in R.equals terms,
 * to at least one element of the given list or false otherwise.
 * Given list can be a string.
 *
 * Like {@link http://ramdajs.com/docs/#contains|R.contains} but with argument order reversed.
 *
 * @func contained
 * @aliases included
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @deprecated since v2.12.0; please use RA.included alias
 * @category List
 * @sig [a] -> a -> Boolean
 * @param {Array|String} list The list to consider
 * @param {*} a The item to compare against
 * @return {boolean} Returns Boolean `true` if an equivalent item is in the list or `false` otherwise
 * @see {@link http://ramdajs.com/docs/#contains|R.contains}
 * @example
 *
 * RA.contained([1, 2, 3], 3); //=> true
 * RA.contained([1, 2, 3], 4); //=> false
 * RA.contained([{ name: 'Fred' }], { name: 'Fred' }); //=> true
 * RA.contained([[42]], [42]); //=> true
 */

var contained = Object(external_ramda_["flip"])(external_ramda_["contains"]);
/* harmony default export */ var src_contained = (contained);
// CONCATENATED MODULE: ./src/move.js

/**
 * Returns a new list with the item at the position `fromIdx` moved to the position `toIdx`. If the
 * `toIdx` is out of the `list` range, the item will be placed at the last position of the `list`.
 * When negative indices are provided, the behavior of the move is unspecified.
 *
 * @func move
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @param {Number} fromIdx The position of item to be moved
 * @param {Number} toIdx The position of item after move
 * @param {Array} list The list containing the item to be moved
 * @return {Array}
 * @example
 *
 * const list = ['a', 'b', 'c', 'd', 'e'];
 * RA.move(1, 3, list) //=> ['a', 'c', 'd', 'b', 'e']
 */

var move = Object(external_ramda_["curry"])(function (fromIdx, toIdx, list) {
  return Object(external_ramda_["compose"])(Object(external_ramda_["insert"])(toIdx, Object(external_ramda_["nth"])(fromIdx, list)), Object(external_ramda_["remove"])(fromIdx, 1))(list);
});
/* harmony default export */ var src_move = (move);
// CONCATENATED MODULE: ./src/internal/compareLength.js

var compareLength = Object(external_ramda_["curry"])(function (comparator, value, list) {
  return Object(external_ramda_["compose"])(comparator(value), external_ramda_["length"])(list);
});
/* harmony default export */ var internal_compareLength = (compareLength);
// CONCATENATED MODULE: ./src/lengthGt.js


/**
 * Returns `true` if the supplied list or string has a length greater than `valueLength`.
 *
 * @func lengthGt
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthEq|lengthEq}, {@link RA.lengthNotEq|lengthNotEq}, {@link RA.lengthLt|lengthLt}, {@link RA.lengthLte|lengthLte}, {@link RA.lengthGte|lengthGte}, {@link http://ramdajs.com/docs/#gt|gt},  {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthGt(3, [1,2,3,4]); //=> true
 * RA.lengthGt(3, [1,2,3]); //=> false
 */

var lengthGt = internal_compareLength(Object(external_ramda_["flip"])(external_ramda_["gt"]));
/* harmony default export */ var src_lengthGt = (lengthGt);
// CONCATENATED MODULE: ./src/lengthLt.js


/**
 * Returns `true` if the supplied list or string has a length less than `valueLength`.
 *
 * @func lengthLt
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthEq|lengthEq}, {@link RA.lengthNotEq|lengthNotEq}, {@link RA.lengthGt|lengthGt}, {@link RA.lengthLte|lengthLte}, {@link RA.lengthGte|lengthGte}, {@link http://ramdajs.com/docs/#lt|lt}, {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthLt(3, [1,2]); //=> true
 * RA.lengthLt(3, [1,2,3]); //=> false
 */

var lengthLt = internal_compareLength(Object(external_ramda_["flip"])(external_ramda_["lt"]));
/* harmony default export */ var src_lengthLt = (lengthLt);
// CONCATENATED MODULE: ./src/lengthGte.js


/**
 * Returns `true` if the supplied list or string has a length greater than or equal to
 * `valueLength`.
 *
 * @func lengthGte
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthEq|lengthEq}, {@link RA.lengthNotEq|lengthNotEq}, {@link RA.lengthLt|lengthLt}, {@link RA.lengthGt|lengthGt}, {@link RA.lengthLte|lengthLte}, {@link http://ramdajs.com/docs/#gte|gte}, {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthGte(3, [1,2,3,4]); //=> true
 * RA.lengthGte(3, [1,2,3]); //=> true
 * RA.lengthGte(3, [1,2]); //=> false
 */

var lengthGte = internal_compareLength(Object(external_ramda_["flip"])(external_ramda_["gte"]));
/* harmony default export */ var src_lengthGte = (lengthGte);
// CONCATENATED MODULE: ./src/lengthLte.js


/**
 * Returns `true` if the supplied list or string has a length less than or equal to `valueLength`.
 *
 * @func lengthLte
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthEq|lengthEq}, {@link RA.lengthNotEq|lengthNotEq}, {@link RA.lengthLt|lengthLt}, {@link RA.lengthGt|lengthGt}, {@link RA.lengthGte|lengthGte}, {@link http://ramdajs.com/docs/#lte|lte}, {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthLte(3, [1,2]); //=> true
 * RA.lengthLte(3, [1,2,3]); //=> true
 * RA.lengthLte(3, [1,2,3,4]); //=> false
 */

var lengthLte = internal_compareLength(Object(external_ramda_["flip"])(external_ramda_["lte"]));
/* harmony default export */ var src_lengthLte = (lengthLte);
// CONCATENATED MODULE: ./src/lengthEq.js


/**
 * Returns `true` if the supplied list or string has a length equal to `valueLength`.
 *
 * @func lengthEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthNotEq|lengthNotEq}, {@link RA.lengthLt|lengthLt}, {@link RA.lengthGt|lengthGt}, {@link RA.lengthLte|lengthLte}, {@link RA.lengthGte|lengthGte},, {@link http://ramdajs.com/docs/#equals|equals}, {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthEq(3, [1,2,3]); //=> true
 * RA.lengthEq(3, [1,2,3,4]); //=> false
 */

var lengthEq = internal_compareLength(external_ramda_["equals"]);
/* harmony default export */ var src_lengthEq = (lengthEq);
// CONCATENATED MODULE: ./src/lengthNotEq.js


/**
 * Returns `true` if the supplied list or string has a length not equal to `valueLength`.
 *
 * @func lengthNotEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.8.0|v2.8.0}
 * @category List
 * @sig Number -> [*] -> Boolean
 * @param {number} valueLength The length of the list or string
 * @param {Array|string} value The list or string
 * @return {boolean}
 * @see {@link RA.lengthEq|lengthEq}, {@link RA.lengthLt|lengthLt}, {@link RA.lengthGt|lengthGt}, {@link RA.lengthLte|lengthLte}, {@link RA.lengthGte|lengthGte}, {@link http://ramdajs.com/docs/#equals|equals}, {@link http://ramdajs.com/docs/#length|length}
 * @example
 *
 * RA.lengthNotEq(3, [1,2,3,4]); //=> true
 * RA.lengthNotEq(3, [1,2,3]); //=> false
 */

var lengthNotEq = internal_compareLength(Object(external_ramda_["complement"])(external_ramda_["equals"]));
/* harmony default export */ var src_lengthNotEq = (lengthNotEq);
// CONCATENATED MODULE: ./src/allEqual.js


 // Original idea for this function was conceived by https://github.com/jackmellis
// in https://github.com/char0n/ramda-adjunct/pull/513.

/**
 * Returns true if all items in the list are equivalent using `R.equals` for equality comparisons.
 *
 * @func allEqual
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.9.0|v2.9.0}
 * @category List
 * @sig [a] -> Boolean
 * @param {Array} list The list of values
 * @return {boolean}
 * @see {@link https://ramdajs.com/docs/#equals|equals}
 * @example
 *
 * RA.allEqual([ 1, 2, 3, 4 ]); //=> false
 * RA.allEqual([ 1, 1, 1, 1 ]); //=> true
 * RA.allEqual([]); //=> true
 *
 */

var allEqual = _curry1_default()(Object(external_ramda_["pipe"])(external_ramda_["uniq"], src_lengthLte(1)));
/* harmony default export */ var src_allEqual = (allEqual);
// CONCATENATED MODULE: ./src/internal/polyfills/String.repeat.js



var String_repeat_repeat = function repeat(value, count) {
  var validCount = Number(count);

  if (validCount !== count) {
    validCount = 0;
  }

  if (src_isNegative(validCount)) {
    throw new RangeError('repeat count must be non-negative');
  }

  if (src_isNotFinite(validCount)) {
    throw new RangeError('repeat count must be less than infinity');
  }

  validCount = Math.floor(validCount);

  if (value.length === 0 || validCount === 0) {
    return '';
  } // Ensuring validCount is a 31-bit integer allows us to heavily optimize the
  // main part. But anyway, most current (August 2014) browsers can't handle
  // strings 1 << 28 chars or longer, so:
  // eslint-disable-next-line no-bitwise


  if (value.length * validCount >= 1 << 28) {
    throw new RangeError('repeat count must not overflow maximum string size');
  }

  var maxCount = value.length * validCount;
  validCount = Math.floor(Math.log(validCount) / Math.log(2));
  var result = value;

  while (validCount) {
    result += value;
    validCount -= 1;
  }

  result += result.substring(0, maxCount - result.length);
  return result;
};

/* harmony default export */ var String_repeat = (String_repeat_repeat);
// CONCATENATED MODULE: ./src/repeatStr.js



var repeatStrPolyfill = Object(external_ramda_["curry"])(String_repeat);
var repeatStrInvoker = Object(external_ramda_["flip"])(Object(external_ramda_["invoker"])(1, 'repeat'));
/**
 * Constructs and returns a new string which contains the specified
 * number of copies of the string on which it was called, concatenated together.
 *
 * @func repeatStr
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.11.0|v2.11.0}
 * @category List
 * @sig String -> Number -> String
 * @param {string} value String value to be repeated
 * @param {number} count An integer between 0 and +: [0, +), indicating the number of times to repeat the string in the newly-created string that is to be returned
 * @return {string} A new string containing the specified number of copies of the given string
 * @example
 *
 * RA.repeatStr('a', 3); //=> 'aaa'
 */

var repeatStr = src_isFunction(String.prototype.repeat) ? repeatStrInvoker : repeatStrPolyfill;
/* harmony default export */ var src_repeatStr = (repeatStr);
// CONCATENATED MODULE: ./src/allIdentical.js



/**
 * Returns true if all items in the list are equivalent using `R.identical` for equality comparisons.
 *
 * @func allIdentical
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.11.0|v2.11.0}
 * @category List
 * @sig [a] -> Boolean
 * @param {Array} list The list of values
 * @return {boolean}
 * @see {@link https://ramdajs.com/docs/#identical|identical}
 * @example
 *
 * RA.allIdentical([ 1, 2, 3, 4 ]); //=> false
 * RA.allIdentical([ 1, 1, 1, 1 ]); //=> true
 * RA.allIdentical([]); //=> true
 * RA.allIdentical([ {}, {} ]); //=> false
 * RA.allIdentical([ () => {}, () => {} ]); //=> false
 */

var allIdentical = _curry1_default()(Object(external_ramda_["pipe"])(Object(external_ramda_["uniqWith"])(external_ramda_["identical"]), src_lengthLte(1)));
/* harmony default export */ var src_allIdentical = (allIdentical);
// CONCATENATED MODULE: ./src/allIdenticalTo.js

/**
 * Returns true if all items in the list are equivalent to user provided value using `R.identical` for equality comparisons.
 *
 * @func allIdenticalTo
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.11.0|v2.11.0}
 * @category List
 * @sig a -> [b] -> Boolean
 * @param {*} val User provided value to check the `list` against
 * @param {Array} list The list of values
 * @return {boolean}
 * @see {@link RA.allIdentical|allIdentical}, {@link http://ramdajs.com/docs/#identical|R.identical}
 * @example
 *
 * RA.allIdenticalTo(1, [ 1, 2, 3, 4 ]); //=> false
 * RA.allIdenticalTo(1, [ 1, 1, 1, 1 ]); //=> true
 * RA.allIdenticalTo(1, []); //=> true
 * RA.allIdenticalTo({}, [ {}, {} ]); //=> false
 *
 */

var allIdenticalTo = Object(external_ramda_["curry"])(function (val, list) {
  return Object(external_ramda_["all"])(Object(external_ramda_["identical"])(val), list);
});
/* harmony default export */ var src_allIdenticalTo = (allIdenticalTo);
// CONCATENATED MODULE: ./src/allEqualTo.js

/**
 * Returns true if all items in the list are equivalent to user provided value using `R.equals` for equality comparisons.
 *
 * @func allEqualTo
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.11.0|v2.11.0}
 * @category List
 * @sig a -> [b] -> Boolean
 * @param {*} val User provided value to check the `list` against
 * @param {Array} list The list of values
 * @return {boolean}
 * @see {@link RA.allEqual|allEqual}, {@link https://ramdajs.com/docs/#equals|equals}
 * @example
 *
 * RA.allEqualTo(1, [ 1, 2, 3, 4 ]); //=> false
 * RA.allEqualTo(1, [ 1, 1, 1, 1 ]); //=> true
 * RA.allEqualTo({}, [ {}, {} ]); //=> true
 * RA.allEqualTo(1, []); //=> true
 *
 */

var allEqualTo = Object(external_ramda_["curry"])(function (val, list) {
  return Object(external_ramda_["all"])(Object(external_ramda_["equals"])(val), list);
});
/* harmony default export */ var src_allEqualTo = (allEqualTo);
// CONCATENATED MODULE: ./src/paths.js

/**
 * Acts as multiple path: arrays of paths in, array of values out. Preserves order.
 *
 * @func paths
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.2.0|v1.2.0}
 * @category List
 * @sig  [[k]] -> {k: v} - [v]
 * @param {Array} ps The property paths to fetch
 * @param {Object} obj The object to query
 * @return {Array} The corresponding values or partially applied function
 * @see {@link https://github.com/ramda/ramda/wiki/Cookbook#derivative-of-rprops-for-deep-fields|Ramda Cookbook}, {@link http://ramdajs.com/docs/#props|R.props}
 * @example
 *
 * const obj = {
 *   a: { b: { c: 1 } },
 *   x: 2,
 * };
 *
 * RA.paths([['a', 'b', 'c'], ['x']], obj); //=> [1, 2]
 */

var paths = Object(external_ramda_["curry"])(function (ps, obj) {
  return Object(external_ramda_["ap"])([Object(external_ramda_["path"])(external_ramda_["__"], obj)], ps);
});
/* harmony default export */ var src_paths = (paths);
// CONCATENATED MODULE: ./src/renameKeysWith.js

/**
 * Creates a new object with the own properties of the provided object, but the
 * keys renamed according to logic of renaming function.
 *
 * Keep in mind that in the case of keys conflict is behaviour undefined and
 * the result may vary between various JS engines!
 *
 * @func renameKeysWith
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.5.0|v1.5.0}
 * @category Object
 * @sig (a -> b) -> {a: *} -> {b: *}
 * @param {Function} fn Function that renames the keys
 * @param {!Object} obj Provided object
 * @return {!Object} New object with renamed keys
 * @see {@link https://github.com/ramda/ramda/wiki/Cookbook#rename-keys-of-an-object-by-a-function|Ramda Cookbook}, {@link RA.renameKeys|renameKeys}
 * @example
 *
 * RA.renameKeysWith(R.concat('a'), { A: 1, B: 2, C: 3 }) //=> { aA: 1, aB: 2, aC: 3 }
 */

var renameKeysWith = Object(external_ramda_["curry"])(function (fn, obj) {
  return Object(external_ramda_["pipe"])(external_ramda_["toPairs"], Object(external_ramda_["map"])(Object(external_ramda_["over"])(Object(external_ramda_["lensIndex"])(0), fn)), external_ramda_["fromPairs"])(obj);
});
/* harmony default export */ var src_renameKeysWith = (renameKeysWith);
// CONCATENATED MODULE: ./src/renameKeys.js



var renameKeys_valueOrKey = function valueOrKey(keysMap) {
  return function (key) {
    if (Object(external_ramda_["has"])(key, keysMap)) {
      return keysMap[key];
    }

    return key;
  };
};
/**
 * Creates a new object with the own properties of the provided object, but the
 * keys renamed according to the keysMap object as `{oldKey: newKey}`.
 * When some key is not found in the keysMap, then it's passed as-is.
 *
 * Keep in mind that in the case of keys conflict is behaviour undefined and
 * the result may vary between various JS engines!
 *
 * @func renameKeys
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.5.0|v1.5.0}
 * @category Object
 * @sig {a: b} -> {a: *} -> {b: *}
 * @param {!Object} keysMap
 * @param {!Object} obj
 * @return {!Object} New object with renamed keys
 * @see {@link https://github.com/ramda/ramda/wiki/Cookbook#rename-keys-of-an-object|Ramda Cookbook}, {@link RA.renameKeysWith|renameKeysWith}
 * @example
 *
 * const input = { firstName: 'Elisia', age: 22, type: 'human' };
 *
 * RA.renameKeys({ firstName: 'name', type: 'kind', foo: 'bar' })(input);
 * //=> { name: 'Elisia', age: 22, kind: 'human' }
 */


var renameKeys = Object(external_ramda_["curry"])(function (keysMap, obj) {
  return src_renameKeysWith(renameKeys_valueOrKey(keysMap), obj);
});
/* harmony default export */ var src_renameKeys = (renameKeys);
// CONCATENATED MODULE: ./src/mergeRight.js

/**
 * Create a new object with the own properties of the second object merged with
 * the own properties of the first object. If a key exists in both objects,
 * the value from the first object will be used. *
 * Putting it simply: it sets properties only if they don't exist.
 *
 * @func mergeRight
 * @deprecated since v2.12.0; available in ramda@0.26.0 as R.mergeLeft
 * @aliases mergeLeft, resetToDefault
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.6.0|v1.6.0}
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} r Destination
 * @param {Object} l Source
 * @return {Object}
 * @see {@link http://ramdajs.com/docs/#merge|R.merge}, {@link https://github.com/ramda/ramda/wiki/Cookbook#set-properties-only-if-they-dont-exist|Ramda Cookbook}
 * @example
 *
 * RA.mergeRight({ 'age': 40 }, { 'name': 'fred', 'age': 10 });
 * //=> { 'name': 'fred', 'age': 40 }
 */

var mergeRight = Object(external_ramda_["flip"])(external_ramda_["merge"]);
/* harmony default export */ var src_mergeRight = (mergeRight);
// CONCATENATED MODULE: ./src/mergeProps.js

/**
 * Functional equivalent of merging object properties with object spread operator.
 *
 * @func mergeProps
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.17.0|v1.17.0}
 * @category Object
 * @sig [k] -> {k: {a}} -> {a}
 * @see {@link RA.mergePaths|mergePaths}
 * @param {!Array} ps The property names to merge
 * @param {!Object} obj The object to query
 * @return {!Object} The object composed of merged properties of obj
 * @example
 *
 * const obj = {
 *   foo: { fooInner: 1 },
 *   bar: { barInner: 2 }
 * };
 *
 * { ...obj.foo, ...obj.bar }; //=> { fooInner: 1, barInner: 2 }
 * RA.mergeProps(['foo', 'bar'], obj); //=> { fooInner: 1, barInner: 2 }
 */

var mergeProps = Object(external_ramda_["curryN"])(2, Object(external_ramda_["pipe"])(external_ramda_["props"], external_ramda_["mergeAll"]));
/* harmony default export */ var src_mergeProps = (mergeProps);
// CONCATENATED MODULE: ./src/mergePaths.js


/**
 * Merge objects under corresponding paths.
 *
 * @func mergePaths
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.17.0|v1.17.0}
 * @category Object
 * @sig [[k]] -> {k: {a}} -> {a}
 * @see {@link RA.mergeProps|mergeProps}
 * @param {!Array} paths The property paths to merge
 * @param {!Object} obj The object to query
 * @return {!Object} The object composed of merged property paths of obj
 * @example
 *
 * const obj = {
 *   foo: { fooInner: { fooInner2: 1 } },
 *   bar: { barInner: 2 }
 * };
 *
 * { ...obj.foo.fooInner, ...obj.bar }; //=>  { fooInner2: 1, barInner: 2 }
 * RA.mergePaths([['foo', 'fooInner'], ['bar']], obj); //=> { fooInner2: 1, barInner: 2 }
 */

var mergePaths = Object(external_ramda_["curryN"])(2, Object(external_ramda_["pipe"])(src_paths, external_ramda_["mergeAll"]));
/* harmony default export */ var src_mergePaths = (mergePaths);
// CONCATENATED MODULE: ./src/mergePath.js


/**
 * Create a new object with the own properties of the object under the `path`
 * merged with the own properties of the provided `source`.
 * If a key exists in both objects, the value from the `source` object will be used.
 *
 * @func mergePath
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.18.0|v1.18.0}
 * @category Object
 * @sig [k] -> {a} -> {k: {a}} -> {k: {a}}
 * @see {@link RA.mergeProp|mergeProp}
 * @param {!Array} path The property path of the destination object
 * @param {!Object} source The source object
 * @param {!Object} obj The object that has destination object under corresponding property path
 * @return {!Object} The new version of object
 * @example
 *
 * RA.mergePath(
 *  ['outer', 'inner'],
 *  { foo: 3, bar: 4 },
 *  { outer: { inner: { foo: 2 } } }
 * ); //=> { outer: { inner: { foo: 3, bar: 4 } }
 */

var mergePath = Object(external_ramda_["curry"])(function (path, source, obj) {
  return Object(external_ramda_["over"])(Object(external_ramda_["lensPath"])(path), src_mergeRight(source), obj);
});
/* harmony default export */ var src_mergePath = (mergePath);
// CONCATENATED MODULE: ./src/mergeProp.js


/**
 * Create a new object with the own properties of the object under the `p`
 * merged with the own properties of the provided `source`.
 * If a key exists in both objects, the value from the `source` object will be used.
 *
 * @func mergeProp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.18.0|v1.18.0}
 * @category Object
 * @sig [k] -> {a} -> {k: {a}} -> {k: {a}}
 * @see {@link RA.mergePath|mergePath}
 * @param {!Array} p The property of the destination object
 * @param {!Object} source The source object
 * @param {!Object} obj The object that has destination object under corresponding property
 * @return {!Object} The new version of object
 * @example
 *
 * RA.mergeProp(
 *  'outer',
 *  { foo: 3, bar: 4 },
 *  { outer: { foo: 2 } }
 * ); //=> { outer: { foo: 3, bar: 4 } };
 */

var mergeProp = Object(external_ramda_["curry"])(function (p, subj, obj) {
  return src_mergePath(Object(external_ramda_["of"])(p), subj, obj);
});
/* harmony default export */ var src_mergeProp = (mergeProp);
// CONCATENATED MODULE: ./src/omitBy.js

/* eslint-disable max-len */

/**
 * Returns a partial copy of an object containing only the keys
 * that don't satisfy the supplied predicate.
 *
 * @func omitBy
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Object
 * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
 * @param {!Function} pred A predicate to determine whether or not a key should be included on the output object
 * @param {!Object} obj The object to copy from
 * @return {!Object} A new object only with properties that don't satisfy `pred`
 *
 * @example
 *
 * const isLowerCase = (val, key) => key.toLowerCase() === key;
 * RA.omitBy(isLowerCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
 */

/* eslint-enable max-len */

var omitBy = Object(external_ramda_["useWith"])(external_ramda_["pickBy"], [external_ramda_["complement"], external_ramda_["identity"]]);
/* harmony default export */ var src_omitBy = (omitBy);
// CONCATENATED MODULE: ./src/viewOr.js

/**
 * Returns a "view" of the given data structure, determined by the given lens.
 * The lens's focus determines which portion of the data structure is visible.
 * Returns the defaultValue if "view" is null, undefined or NaN; otherwise the "view" is returned.
 *
 * @func viewOr
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|1.13.0}
 * @category Object
 * @typedef Lens s b = Functor f => (b -> f b) -> s -> f s
 * @sig a -> Lens s b -> s -> b | a
 * @see {@link http://ramdajs.com/docs/#view|R.view}
 * @param {*} defaultValue The default value
 * @param {Function} lens Van Laarhoven lens
 * @param {*} data The data structure
 * @returns {*} "view" or defaultValue
 *
 * @example
 *
 * RA.viewOr('N/A', R.lensProp('x'), {}); // => 'N/A'
 * RA.viewOr('N/A', R.lensProp('x'), { x: 1 }); // => 1
 * RA.viewOr('some', R.lensProp('y'), { y: null }); // => 'some'
 * RA.viewOr('some', R.lensProp('y'), { y: false }); // => false
 */

var viewOr = Object(external_ramda_["curryN"])(3, function (defaultValue, lens, data) {
  return Object(external_ramda_["defaultTo"])(defaultValue, Object(external_ramda_["view"])(lens, data));
});
/* harmony default export */ var src_viewOr = (viewOr);
// CONCATENATED MODULE: ./src/hasPath.js


/**
 * Returns whether or not an object has an own property with the specified name at a given path.
 *
 * @func hasPath
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.14.0|v1.14.0}
 * @deprecated since v2.12.0; ramda@0.26.0 contains hasPath
 * @category Object
 * @typedef Idx = String | Int
 * @sig [Idx] -> {a} -> Boolean
 * @param {Array.<string|number>} path The path of the nested property
 * @param {Object} obj The object to test
 * @return {boolean}
 * @see {@link http://ramdajs.com/docs/#has|R.has}
 * @example
 *
 * RA.hasPath(['a', 'b'], { a: { b: 1 } }); //=> true
 * RA.hasPath(['a', 'b', 'c'], { a: { b: 1 } }); //=> false
 * RA.hasPath(['a', 'b'], { a: { } }); //=> false
 * RA.hasPath([0], [1, 2]); //=> true
 */

var hasPath = Object(external_ramda_["curryN"])(2, function (objPath, obj) {
  var prop = Object(external_ramda_["head"])(objPath); // termination conditions

  if (Object(external_ramda_["length"])(objPath) === 0 || !src_isObj(obj)) {
    return false;
  }

  if (Object(external_ramda_["length"])(objPath) === 1) {
    return Object(external_ramda_["has"])(prop, obj);
  }

  return hasPath(Object(external_ramda_["tail"])(objPath), Object(external_ramda_["path"])([prop], obj)); // base case
});
/* harmony default export */ var src_hasPath = (hasPath);
// CONCATENATED MODULE: ./src/spreadPath.js

/**
 * Spreads object under property path onto provided object.
 * It's like {@link RA.flattenPath|flattenPath}, but removes object under the property path.
 *
 * @func spreadPath
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Object
 * @typedef Idx = String | Int
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {!Array.<string|number>} path The property path to spread
 * @param {!Object} obj The provided object
 * @return {!Object} The result of the spread
 * @see {@link RA.spreadProp|spreadProp}, {@link RA.flattenPath|flattenPath}
 * @example
 *
 * RA.spreadPath(
 *   ['b1', 'b2'],
 *   { a: 1, b1: { b2: { c: 3, d: 4 } } }
 * ); // => { a: 1, c: 3, d: 4, b1: {} };
 */

var spreadPath = Object(external_ramda_["curryN"])(2, Object(external_ramda_["converge"])(external_ramda_["merge"], [external_ramda_["dissocPath"], Object(external_ramda_["pathOr"])({})]));
/* harmony default export */ var src_spreadPath = (spreadPath);
// CONCATENATED MODULE: ./src/spreadProp.js


/**
 * Spreads object under property onto provided object.
 * It's like {@link RA.flattenProp|flattenProp}, but removes object under the property.
 *
 * @func spreadProp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Object
 * @typedef Idx = String | Int
 * @sig Idx -> {k: v} -> {k: v}
 * @param {!string|number} prop The property to spread
 * @param {!Object} obj The provided object
 * @return {!Object} The result of the spread
 * @see {@link RA.spreadPath|spreadPath}, {@link RA.flattenProp|flattenProp}
 * @example
 *
 * RA.spreadProp('b', { a: 1, b: { c: 3, d: 4 } }); // => { a: 1, c: 3, d: 4 };
 */

var spreadProp = Object(external_ramda_["curry"])(function (prop, obj) {
  return src_spreadPath(Object(external_ramda_["of"])(prop), obj);
});
/* harmony default export */ var src_spreadProp = (spreadProp);
// CONCATENATED MODULE: ./src/flattenPath.js

/**
 * Flattens a property path so that its fields are spread out into the provided object.
 * It's like {@link RA.spreadPath|spreadPath}, but preserves object under the property path.
 *
 * @func flattenPath
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Object
 * @typedef Idx = String | Int
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {!Array.<string|number>} path The property path to flatten
 * @param {!Object} obj The provided object
 * @return {!Object} The flattened object
 * @see {@link RA.flattenProp|flattenProp}, {@link RA.spreadPath|spreadPath}
 * @example
 *
 * RA.flattenPath(
 *   ['b1', 'b2'],
 *   { a: 1, b1: { b2: { c: 3, d: 4 } } }
 * ); // => { a: 1, c: 3, d: 4, b1: { b2: { c: 3, d: 4 } } };
 */

var flattenPath = Object(external_ramda_["curry"])(function (path, obj) {
  return Object(external_ramda_["merge"])(obj, Object(external_ramda_["pathOr"])({}, path, obj));
});
/* harmony default export */ var src_flattenPath = (flattenPath);
// CONCATENATED MODULE: ./src/flattenProp.js


/**
 * Flattens a property so that its fields are spread out into the provided object.
 * It's like {@link RA.spreadProp|spreadProp}, but preserves object under the property path.
 *
 * @func flattenProp
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|v1.19.0}
 * @category Object
 * @typedef Idx = String | Int
 * @sig [Idx] -> {k: v} -> {k: v}
 * @param {!string|number} prop The property to flatten
 * @param {!Object} obj The provided object
 * @return {!Object} The flattened object
 * @see {@link RA.flattenPath|flattenPath}, {@link RA.spreadProp|spreadProp}
 * @example
 *
 * RA.flattenProp(
 *   'b',
 *   { a: 1, b: { c: 3, d: 4 } }
 * ); // => { a: 1, c: 3, d: 4, b: { c: 3, d: 4 } };
 */

var flattenProp = Object(external_ramda_["curry"])(function (prop, obj) {
  return src_flattenPath(Object(external_ramda_["of"])(prop), obj);
});
/* harmony default export */ var src_flattenProp = (flattenProp);
// CONCATENATED MODULE: ./src/lensEq.js

/**
 * Returns `true` if data structure focused by the given lens equals provided value.
 *
 * @func lensEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|1.13.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig  Lens s a -> b -> s -> Boolean
 * @see {@link RA.lensNotEq|lensNotEq}
 * @param {function} lens Van Laarhoven lens
 * @param {*} value The value to compare the focused data structure with
 * @param {*} data The data structure
 * @return {boolean} `true` if the focused data structure equals value, `false` otherwise
 *
 * @example
 *
 * RA.lensEq(R.lensIndex(0), 1, [0, 1, 2]); // => false
 * RA.lensEq(R.lensIndex(1), 1, [0, 1, 2]); // => true
 * RA.lensEq(R.lensPath(['a', 'b']), 'foo', { a: { b: 'foo' } }) // => true
 */

var lensEq = Object(external_ramda_["curryN"])(3, function (lens, val, data) {
  return Object(external_ramda_["pipe"])(Object(external_ramda_["view"])(lens), Object(external_ramda_["equals"])(val))(data);
});
/* harmony default export */ var src_lensEq = (lensEq);
// CONCATENATED MODULE: ./src/lensNotEq.js


/**
 * Returns `true` if data structure focused by the given lens doesn't equal provided value.
 *
 * @func lensNotEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|1.13.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Lens s a -> b -> s -> Boolean
 * @see {@link RA.lensEq|lensEq}
 * @param {function} lens Van Laarhoven lens
 * @param {*} value The value to compare the focused data structure with
 * @param {*} data The data structure
 * @return {boolean} `false` if the focused data structure equals value, `true` otherwise
 *
 * @example
 *
 * RA.lensNotEq(R.lensIndex(0), 1, [0, 1, 2]); // => true
 * RA.lensNotEq(R.lensIndex(1), 1, [0, 1, 2]); // => false
 * RA.lensNotEq(R.lensPath(['a', 'b']), 'foo', { a: { b: 'foo' } }) // => false
 */

var lensNotEq = Object(external_ramda_["complement"])(src_lensEq);
/* harmony default export */ var src_lensNotEq = (lensNotEq);
// CONCATENATED MODULE: ./src/lensSatisfies.js


/**
 * Returns `true` if data structure focused by the given lens satisfies the predicate.
 * Note that the predicate is expected to return boolean value and will be evaluated
 * as `false` unless the predicate returns `true`.
 *
 * @func lensSatisfies
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|1.13.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig  Boolean b => (a -> b) -> Lens s a -> s -> b
 * @see {@link RA.lensNotSatisfy|lensNotSatisfy}
 * @param {Function} predicate The predicate function
 * @param {Function} lens Van Laarhoven lens
 * @param {*} data The data structure
 * @return {boolean} `true` if the focused data structure satisfies the predicate, `false` otherwise
 *
 * @example
 *
 * RA.lensSatisfies(RA.isTrue, R.lensIndex(0), [false, true, 1]); // => false
 * RA.lensSatisfies(RA.isTrue, R.lensIndex(1), [false, true, 1]); // => true
 * RA.lensSatisfies(RA.isTrue, R.lensIndex(2), [false, true, 1]); // => false
 * RA.lensSatisfies(R.identity, R.lensProp('x'), { x: 1 }); // => false
 */

var lensSatisfies = Object(external_ramda_["curryN"])(3, function (predicate, lens, data) {
  return Object(external_ramda_["pipe"])(Object(external_ramda_["view"])(lens), predicate, src_isTrue)(data);
});
/* harmony default export */ var src_lensSatisfies = (lensSatisfies);
// CONCATENATED MODULE: ./src/lensNotSatisfy.js


/**
 * Returns `true` if data structure focused by the given lens doesn't satisfy the predicate.
 * Note that the predicate is expected to return boolean value.
 *
 * @func lensNotSatisfy
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.13.0|1.13.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig  Boolean b => (a -> b) -> Lens s a -> s -> b
 * @see {@link RA.lensSatisfies|lensSatisfies}
 * @param {Function} predicate The predicate function
 * @param {Function} lens Van Laarhoven lens
 * @param {*} data The data structure
 * @return {boolean} `false` if the focused data structure satisfies the predicate, `true` otherwise
 *
 * @example
 *
 * RA.lensNotSatisfy(RA.isTrue, R.lensIndex(0), [false, true, 1]); // => true
 * RA.lensNotSatisfy(RA.isTrue, R.lensIndex(1), [false, true, 1]); // => false
 * RA.lensNotSatisfy(RA.isTrue, R.lensIndex(2), [false, true, 1]); // => true
 * RA.lensNotSatisfy(R.identity, R.lensProp('x'), { x: 1 }); // => true
 */

var lensNotSatisfy = Object(external_ramda_["complement"])(src_lensSatisfies);
/* harmony default export */ var src_lensNotSatisfy = (lensNotSatisfy);
// CONCATENATED MODULE: ./src/fantasy-land/util.js
 // type :: Monad a => a -> String

var type = Object(external_ramda_["either"])(Object(external_ramda_["path"])(['@@type']), Object(external_ramda_["path"])(['constructor', '@@type'])); // typeEquals :: Monad a => String -> a -> Boolean

var typeEquals = Object(external_ramda_["curry"])(function (typeIdent, monad) {
  return type(monad) === typeIdent;
}); // isSameType :: (Monad a, Monad b) => a -> b -> Boolean

var isSameType = Object(external_ramda_["curryN"])(2, Object(external_ramda_["useWith"])(external_ramda_["equals"], [type, type])); // isNotSameType :: (Monad a, Monad b) => a -> b -> Boolean

var isNotSameType = Object(external_ramda_["complement"])(isSameType);
// CONCATENATED MODULE: ./src/fantasy-land/traits.js
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var functorTrait = _defineProperty({}, fantasy_land_mapping.map, function (fn) {
  return this.constructor[fantasy_land_mapping.of](fn(this.value));
});
var applyTrait = _defineProperty({}, fantasy_land_mapping.ap, function (applyWithFn) {
  var _this = this;

  return applyWithFn.map(function (fn) {
    return fn(_this.value);
  });
});
var setoidTrait = _defineProperty({}, fantasy_land_mapping.equals, function (setoid) {
  return isSameType(this, setoid) && Object(external_ramda_["equals"])(this.value, setoid.value);
});
var semigroupTrait = _defineProperty({}, fantasy_land_mapping.concat, function (semigroup) {
  var concatenatedValue = this.value;

  if (src_isString(this.value) || src_isNumber(this.value)) {
    concatenatedValue = this.value + semigroup.value;
  } else if (Object(external_ramda_["pathSatisfies"])(src_isFunction, ['value', fantasy_land_mapping.concat], this)) {
    concatenatedValue = this.value[fantasy_land_mapping.concat](semigroup.value);
  } else if (Object(external_ramda_["pathSatisfies"])(src_isFunction, ['value', 'concat'], this)) {
    concatenatedValue = this.value.concat(semigroup.value);
  }

  return this.constructor[fantasy_land_mapping.of](concatenatedValue);
});
var chainTrait = _defineProperty({}, fantasy_land_mapping.chain, function (fn) {
  var newChain = fn(this.value);
  return isSameType(this, newChain) ? newChain : this;
});
var ordTrait = _defineProperty({}, fantasy_land_mapping.lte, function (ord) {
  return isSameType(this, ord) && (this.value < ord.value || this[fantasy_land_mapping.equals](ord));
});
// CONCATENATED MODULE: ./src/fantasy-land/Identity.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // we do this here for jsdocs generate properly

var Identity_of = fantasy_land_mapping.of,
    _ap = fantasy_land_mapping.ap,
    _map = fantasy_land_mapping.map,
    _equals = fantasy_land_mapping.equals,
    _concat = fantasy_land_mapping.concat,
    _chain = fantasy_land_mapping.chain,
    _lte = fantasy_land_mapping.lte,
    _empty = fantasy_land_mapping.empty,
    _contramap = fantasy_land_mapping.contramap;
/**
 * The simplest {@link https://github.com/fantasyland/fantasy-land|fantasy-land}
 * compatible monad which attaches no information to values.
 *
 * The Identity type is a very simple type that has no interesting side effects and
 * is effectively just a container of some value. So why does it exist ?
 * The Identity type is often used as the base monad of a monad
 * transformer when no other behaviour is required.
 *
 * @memberOf RA
 * @implements
 * {@link https://github.com/fantasyland/fantasy-land#apply|Apply},
 * {@link https://github.com/fantasyland/fantasy-land#applicative|Applicative},
 * {@link https://github.com/fantasyland/fantasy-land#functor|Functor},
 * {@link https://github.com/fantasyland/fantasy-land#setoid|Setoid},
 * {@link https://github.com/fantasyland/fantasy-land#semigroup|Semigroup},
 * {@link https://github.com/fantasyland/fantasy-land#chain|Chain},
 * {@link https://github.com/fantasyland/fantasy-land#monad|Monad},
 * {@link https://github.com/fantasyland/fantasy-land#ord|Ord},
 * {@link https://github.com/fantasyland/fantasy-land#monoid|Monoid*},
 * {@link https://github.com/fantasyland/fantasy-land#contravariant|Contravariant}
 * @since {@link https://char0n.github.io/ramda-adjunct/1.8.0|v1.8.0}
 */

var Identity_Identity =
/*#__PURE__*/
function () {
  _createClass(Identity, null, [{
    key: Identity_of,

    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#applicative|Applicative} specification.
     *
     * @static
     * @sig of :: Applicative f => a -> f a
     * @param {*} value
     * @returns {RA.Identity}
     * @example
     *
     * const a = Identity.of(1); //=> Identity(1)
     */
    value: function value(_value) {
      return new Identity(_value);
    }
  }, {
    key: "of",
    value: function of(value) {
      return new Identity(value);
    }
    /**
     * @static
     */

  }, {
    key: '@@type',
    get: function get() {
      return 'RA/Identity';
    }
    /**
     * Private constructor. Use {@link RA.Identity.of|Identity.of} instead.
     *
     * @private
     * @param {*} value
     * @return {RA.Identity}
     */

  }]);

  function Identity(value) {
    _classCallCheck(this, Identity);

    this.value = value;
  }
  /**
   * Catamorphism for a value.
   * @returns {*}
   * @example
   *
   * const a = Identity.of(1);
   * a.get(); //=> 1
   */


  _createClass(Identity, [{
    key: "get",
    value: function get() {
      return this.value;
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#apply|Apply} specification.
     *
     * @sig ap :: Apply f => f a ~> f (a -> b) -> f b
     * @param {RA.Identity} applyWithFn
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1).map(a => b => a + b);
     *
     * a.ap(b); //=> Identity(2)
     */

  }, {
    key: _ap,
    value: function value(applyWithFn) {
      return applyTrait[_ap].call(this, applyWithFn);
    }
  }, {
    key: "ap",
    value: function ap(applyWithFn) {
      return this[_ap](applyWithFn);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#functor|Functor} specification.
     *
     * @sig map :: Functor f => f a ~> (a -> b) -> f b
     * @param {Function} fn
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * a.map(a => a + 1); //=> Identity(2)
     */

  }, {
    key: _map,
    value: function value(fn) {
      return functorTrait[_map].call(this, fn);
    }
  }, {
    key: "map",
    value: function map(fn) {
      return this[_map](fn);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#setoid|Setoid} specification.
     *
     * @sig equals :: Setoid a => a ~> a -> Boolean
     * @param {RA.Identity} setoid
     * @return {boolean}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * const c = Identity.of(2);
     *
     * a.equals(b); //=> true
     * a.equals(c); //=> false
     */

  }, {
    key: _equals,
    value: function value(setoid) {
      return setoidTrait[_equals].call(this, setoid);
    }
  }, {
    key: "equals",
    value: function equals(setoid) {
      return this[_equals](setoid);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#semigroup|Semigroup} specification.
     *
     * @sig concat :: Semigroup a => a ~> a -> a
     * @param {RA.Identity} semigroup
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * a.concat(b); //=> 2
     *
     * const c = Identity.of('c');
     * const d = Identity.of('d');
     * c.concat(d); //=> 'cd'
     *
     * const e = Identity.of(['e']);
     * const f = Identity.of(['f']);
     * e.concat(f); //=> ['e', 'f']
     */

  }, {
    key: _concat,
    value: function value(semigroup) {
      return semigroupTrait[_concat].call(this, semigroup);
    }
  }, {
    key: "concat",
    value: function concat(semigroup) {
      return this[_concat](semigroup);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#chain|Chain} specification.
     *
     * @sig chain :: Chain m => m a ~> (a -> m b) -> m b
     * @param {Function} fn Function returning the value of the same {@link https://github.com/fantasyland/fantasy-land#semigroup|Chain}
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const fn = val => Identity.of(val + 1);
     *
     * a.chain(fn).chain(fn); //=> Identity(3)
     */

  }, {
    key: _chain,
    value: function value(fn) {
      return chainTrait[_chain].call(this, fn);
    }
  }, {
    key: "chain",
    value: function chain(fn) {
      return this[_chain](fn);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#ord|Ord} specification.
     *
     * @sig lte :: Ord a => a ~> a -> Boolean
     * @param {RA.Identity} ord
     * @return {boolean}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * const c = Identity.of(2);
     *
     * a.lte(b); //=> true
     * a.lte(c); //=> true
     * c.lte(a); //=> false
     */

  }, {
    key: _lte,
    value: function value(ord) {
      return ordTrait[_lte].call(this, ord);
    }
  }, {
    key: "lte",
    value: function lte(ord) {
      return this[_lte](ord);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#monoid|Monoid*} specification.
     * Partial implementation of Monoid specification. `empty` method on instance only, returning
     * identity value of the wrapped type. Using `R.empty` under the hood.
     *
     *
     * @sig empty :: Monoid m => () -> m
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of('test');
     * const i = a.empty();
     *
     * a.concat(i); //=> Identity('string');
     * i.concat(a); //=> Identity('string');
     */

  }, {
    key: _empty,
    value: function value() {
      return this.constructor.of(Object(external_ramda_["empty"])(this.value));
    }
  }, {
    key: "empty",
    value: function empty() {
      return this[_empty]();
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#contravariant|Contravariant} specification.
     *
     * @sig contramap :: Contravariant f => f a ~> (b -> a) -> f b
     * @param {Function} fn
     * @return {RA.Identity}
     * @example
     *
     * const identity = a => a;
     * const add1 = a => a + 1;
     * const divide2 = a => a / 2;
     *
     * Identity.of(divide2).contramap(add1).get()(3); //=> 2
     * Identity.of(identity).contramap(divide2).contramap(add1).get()(3); //=> 2
     * Identity.of(identity).contramap(a => divide2(add1(a))).get()(3); //=> 2
     */

  }, {
    key: _contramap,
    value: function value(fn) {
      var _this = this;

      return this.constructor.of(function (value) {
        return _this.value(fn(value));
      });
    }
  }, {
    key: "contramap",
    value: function contramap(fn) {
      return this[_contramap](fn);
    }
  }]);

  return Identity;
}();

/* harmony default export */ var fantasy_land_Identity = (Identity_Identity);
// CONCATENATED MODULE: ./src/lensTraverse.js


/**
 * Creates a [Traversable](https://github.com/fantasyland/fantasy-land#traversable) lens
 * from an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning function.
 *
 * When executed, it maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
 * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
 * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
 * into an Applicative of Traversable.
 *
 * Dispatches to the `traverse` method of the third argument, if present.
 *
 * @func lensTraverse
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.7.0|2.7.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig Applicative f => (a -> f a) -> Lens s a
 * @param {!function} of The Applicative-returning function
 * @return {!function} The Traversable lens
 * @see {@link http://ramdajs.com/docs/#lens|R.lens}, {@link http://ramdajs.com/docs/#traverse|R.traverse}
 *
 * @example
 *
 * const maybeLens = RA.lensTraverse(Maybe.of);
 * const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)
 *
 * R.over(maybeLens, safeDiv(10), [2, 4, 5]); // => Just([5, 2.5, 2])
 * R.over(maybeLens, safeDiv(10), [2, 0, 5]); // => Nothing
 *
 * R.view(maybeLens, [Maybe.Just(2), Maybe.Just(3)]); // => Maybe.Just([2, 3])
 *
 * R.set(maybeLens, Maybe.Just(1), [Maybe.just(2), Maybe.Just(3)]); // => Maybe.Just([1, 1])
 */

var lensTraverse_lensTraverse = function lensTraverse(of) {
  return Object(external_ramda_["curry"])(function (toFunctorFn, target) {
    return fantasy_land_Identity.of(Object(external_ramda_["traverse"])(of, Object(external_ramda_["pipe"])(toFunctorFn, Object(external_ramda_["prop"])('value')), target));
  });
};

/* harmony default export */ var src_lensTraverse = (lensTraverse_lensTraverse);
// CONCATENATED MODULE: ./src/lensIso.js
 // This implementation was highly inspired by the implementations
// in ramda-lens library.
//
// https://github.com/ramda/ramda-lens
// isomorphic :: ((a -> b), (b -> a)) -> Isomorphism
//     Isomorphism = x -> y

var isomorphic = function isomorphic(to, from) {
  var isomorphism = function isomorphism(x) {
    return to(x);
  };

  isomorphism.from = from;
  return isomorphism;
}; // isomorphisms :: ((a -> b), (b -> a)) -> (a -> b)


var lensIso_isomorphisms = function isomorphisms(to, from) {
  return isomorphic(Object(external_ramda_["curry"])(function (toFunctorFn, target) {
    return Object(external_ramda_["map"])(from, toFunctorFn(to(target)));
  }), Object(external_ramda_["curry"])(function (toFunctorFn, target) {
    return Object(external_ramda_["map"])(to, toFunctorFn(from(target)));
  }));
}; // from :: Isomorphism -> a -> b


var lensIso_from = Object(external_ramda_["curry"])(function (isomorphism, x) {
  return isomorphism.from(x);
});
/**
 * Defines an isomorphism that will work like a lens. It takes two functions.
 * The function that converts and the function that recovers.
 *
 * @func lensIso
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/1.19.0|1.19.0}
 * @category Relation
 * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
 * @sig (s -> a) -> (a -> s) -> Lens s a
 * @param {!function} to The function that converts
 * @param {!function} from The function that recovers
 * @return {!function} The isomorphic lens
 * @see {@link http://ramdajs.com/docs/#lens|R.lens}
 *
 * @example
 *
 * const lensJSON = RA.lensIso(JSON.parse, JSON.stringify);
 *
 * R.over(lensJSON, assoc('b', 2), '{"a":1}'); //=> '{"a":1,"b":2}'
 * R.over(RA.lensIso.from(lensJSON), R.replace('}', ',"b":2}'), { a: 1 }); // => { a: 1, b: 2 }
 */

var lensIso = Object(external_ramda_["curry"])(lensIso_isomorphisms);
lensIso.from = lensIso_from;
/* harmony default export */ var src_lensIso = (lensIso);
// CONCATENATED MODULE: ./src/propNotEq.js

/**
 * Returns true if the specified object property is not equal,
 * in R.equals terms, to the given value; false otherwise.
 *
 * @func propNotEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Relation
 * @sig  String -> a -> Object -> Boolean
 * @param {String} name The property to pick
 * @param {a} val The value to compare to
 * @param {Object} object The object, that presumably contains value under the property
 * @return {boolean} Comparison result
 * @see {@link http://ramdajs.com/docs/#propEq|R.propEq}
 * @example
 *
 * const abby = { name: 'Abby', age: 7, hair: 'blond' };
 * const fred = { name: 'Fred', age: 12, hair: 'brown' };
 * const rusty = { name: 'Rusty', age: 10, hair: 'brown' };
 * const alois = { name: 'Alois', age: 15, disposition: 'surly' };
 * const kids = [abby, fred, rusty, alois];
 * const hasNotBrownHair = RA.propNotEq('hair', 'brown');
 *
 * R.filter(hasNotBrownHair, kids); //=> [abby, alois]
 */

var propNotEq = Object(external_ramda_["complement"])(external_ramda_["propEq"]);
/* harmony default export */ var src_propNotEq = (propNotEq);
// CONCATENATED MODULE: ./src/pathNotEq.js

/* eslint-disable max-len */

/**
 * Determines whether a nested path on an object doesn't have a specific value,
 * in R.equals terms. Most likely used to filter a list.
 *
 * @func pathNotEq
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Relation
 * @sig [Idx] => a => {a} => Boolean
 * @sig Idx = String | Int
 * @param {Array} path The path of the nested property to use
 * @param {a} val The value to compare the nested property with
 * @param {Object} object The object to check the nested property in
 * @return {boolean} Returns Boolean `false` if the value equals the nested object property, `true` otherwise
 * @see {@link http://ramdajs.com/docs/#pathEq|R.pathEq}
 * @example
 *
 * const user1 = { address: { zipCode: 90210 } };
 * const user2 = { address: { zipCode: 55555 } };
 * const user3 = { name: 'Bob' };
 * const users = [ user1, user2, user3 ];
 * const isFamous = R.pathNotEq(['address', 'zipCode'], 90210);
 * R.filter(isFamous, users); //=> [ user2, user3 ]
 */

/* eslint-enable max-len */

var pathNotEq = Object(external_ramda_["complement"])(external_ramda_["pathEq"]);
/* harmony default export */ var src_pathNotEq = (pathNotEq);
// CONCATENATED MODULE: ./src/inRange.js

var inRangeImp = Object(external_ramda_["ifElse"])(external_ramda_["gte"], function () {
  throw new Error('low must not be greater than high in inRange(low, high, value)');
}, Object(external_ramda_["useWith"])(external_ramda_["both"], [external_ramda_["lte"], external_ramda_["gt"]]));
/**
 * Checks if `value` is between `low` and up to but not including `high`.
 *
 * @func inRange
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.7.0|v2.7.0}
 * @category Relation
 * @sig Number -> Number -> Number -> Boolean
 * @param {Number} low Start of the range
 * @param {Number} high The end of the range
 * @param {Number} value The value to test
 * @return {boolean}
 * @throws {Error} When `low` is greater than or equal to `high`
 * @example
 *
 * RA.inRange(0, 5, 3); //=> true
 * RA.inRange(0, 5, 0); //=> true
 * RA.inRange(0, 5, 4); //=> true
 * RA.inRange(0, 5, 5); //=> false
 * RA.inRange(0, 5, -1); //=> false
 */

/* harmony default export */ var inRange = (Object(external_ramda_["curry"])(function (low, high, value) {
  return inRangeImp(low, high)(value);
}));
// CONCATENATED MODULE: ./src/defaultWhen.js

/**
 * Returns the second argument if predicate function returns `true`,
 * otherwise the third argument is returned.
 *
 * @func defaultWhen
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.2.0|v2.2.0}
 * @category Logic
 * @sig  (a -> Boolean) -> b -> a -> a | b
 * @param {!function} predicate The predicate function
 * @param {*} defaultVal The default value
 * @param {*} val `val` will be returned instead of `defaultVal` if predicate returns false
 * @return {*} The `val` if predicate returns `false`, otherwise the default value
 * @see {@link http://ramdajs.com/docs/#defaultTo|R.defaultTo}
 * @example
 *
 * RA.defaultWhen(RA.isNull, 1, null); // => 1
 * RA.defaultWhen(RA.isNull, 1, 2); // => 2
 */

var defaultWhen = Object(external_ramda_["curry"])(function (predicate, defaultVal, val) {
  return predicate(val) ? defaultVal : val;
});
/* harmony default export */ var src_defaultWhen = (defaultWhen);
// CONCATENATED MODULE: ./src/notBoth.js

/* eslint-disable max-len */

/**
 * A function which calls the two provided functions and returns the complement of `&&`ing the
 * results.
 * It returns true if the first function is false-y and the complement of the second function
 * otherwise. Note that this is short-circuited, meaning that the second function will not be
 * invoked if the first returns a false-y value. In short it will return true unless both predicates
 * return true.
 *
 * In addition to functions, `RA.notBoth` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func notBoth
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} Returns a function that applies its arguments to `f` and `g` and returns the complement of `&&`ing their outputs together.
 * @see {@link http://ramdajs.com/docs/#both|R.both}
 * @example
 *
 * const gt10 = R.gt(R.__, 10)
 * const even = (x) => x % 2 === 0;
 * const f = RA.notBoth(gt10, even);
 *
 * f(12); //=> false
 * f(8); //=> true
 * f(11); //=> true
 * f(9); //=> true
 */

/* eslint-enable max-len */

var notBoth = Object(external_ramda_["compose"])(external_ramda_["complement"], external_ramda_["both"]);
/* harmony default export */ var src_notBoth = (notBoth);
// CONCATENATED MODULE: ./src/neither.js

/* eslint-disable max-len */

/**
 * A function which calls the two provided functions and returns the complement of `||`ing the
 * results.
 * It returns false if the first function is truth-y and the complement of the second function
 * otherwise. Note that this is short-circuited, meaning that the second function will not be
 * invoked if the first returns a truth-y value. In short it will return true if neither predicate
 * returns true.
 *
 * In addition to functions, `RA.neither` also accepts any fantasy-land compatible
 * applicative functor.
 *
 * @func neither
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.3.0|v2.3.0}
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
 * @param {Function} f A predicate
 * @param {Function} g Another predicate
 * @return {Function} Returns a function that applies its arguments to `f` and `g` and returns the complement of `||`ing their outputs together.
 * @see {@link http://ramdajs.com/docs/#either|R.either}, {@link http://ramdajs.com/docs/#or|R.or}
 * @example
 *
 * const gt10 = R.gt(R.__, 10)
 * const even = (x) => x % 2 === 0;
 * const f = RA.neither(gt10, even);
 *
 * f(12); //=> false
 * f(8); //=> false
 * f(11); //=> false
 * f(9); //=> true
 */

/* eslint-enable max-len */

var neither = Object(external_ramda_["compose"])(external_ramda_["complement"], external_ramda_["either"]);
/* harmony default export */ var src_neither = (neither);
// CONCATENATED MODULE: ./src/notAllPass.js

/**
 * Takes a list of predicates and returns a predicate that returns true for a given list of
 * arguments if one or more of the provided predicates is not satisfied by those arguments. It is
 * the complement of Ramda's allPass.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func notAllPass
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.4.0|v2.4.0}
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see {@link http://ramdajs.com/docs/#allPass|R.allPass}
 * @example
 *
 * const gt10 = R.gt(R.__, 10)
 * const even = (x) => x % 2 === 0;
 * const f = RA.notAllPass([gt10, even]);
 *
 * f(12); //=> false
 * f(8); //=> true
 * f(11); //=> true
 * f(9); //=> true
 */

var notAllPass = Object(external_ramda_["compose"])(external_ramda_["complement"], external_ramda_["allPass"]);
/* harmony default export */ var src_notAllPass = (notAllPass);
// CONCATENATED MODULE: ./src/nonePass.js

/**
 * Takes a list of predicates and returns a predicate that returns true for a given list of
 * arguments if none of the provided predicates are satisfied by those arguments. It is the
 * complement of Ramda's anyPass.
 *
 * The function returned is a curried function whose arity matches that of the
 * highest-arity predicate.
 *
 * @func nonePass
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.5.0|v2.5.0}
 * @category Logic
 * @sig [(*... -> Boolean)] -> (*... -> Boolean)
 * @param {Array} predicates An array of predicates to check
 * @return {Function} The combined predicate
 * @see {@link http://ramdajs.com/docs/#anyPass|R.anyPass}
 * @example
 *
 * const gt10 = R.gt(R.__, 10)
 * const even = (x) => x % 2 === 0;
 * const f = RA.nonePass([gt10, even]);
 *
 * f(12); //=> false
 * f(8); //=> false
 * f(11); //=> false
 * f(9); //=> true
 */

var nonePass = Object(external_ramda_["compose"])(external_ramda_["complement"], external_ramda_["anyPass"]);
/* harmony default export */ var src_nonePass = (nonePass);
// CONCATENATED MODULE: ./src/argsPass.js



/**
 * Takes a combining predicate and a list of functions and returns a function which will map the
 * arguments it receives to the list of functions and returns the result of passing the values
 * returned from each function to the combining predicate. A combining predicate is a function that
 * combines a list of Boolean values into a single Boolean value, such as `R.any` or `R.all`. It
 * will test each value using `RA.isTruthy`, meaning the functions don't necessarily have to be
 * predicates.
 *
 * The function returned is curried to the number of functions supplied, and if called with more
 * arguments than functions, any remaining arguments are passed in to the combining predicate
 * untouched.
 *
 * @func argsPass
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.7.0|v2.7.0}
 * @category Logic
 * @sig ((* -> Boolean) -> [*] -> Boolean) -> [(* -> Boolean), ...] -> (*...) -> Boolean
 * @param {Function} combiningPredicate The predicate used to combine the values returned from the
 * list of functions
 * @param {Array} functions List of functions
 * @return {boolean} Returns the combined result of mapping arguments to functions
 * @example
 *
 * RA.argsPass(R.all, [RA.isArray, RA.isBoolean, RA.isString])([], false, 'abc') //=> true
 * RA.argsPass(R.all, [RA.isArray, RA.isBoolean, RA.isString])([], false, 1) //=> false
 * RA.argsPass(R.any, [RA.isArray, RA.isBoolean, RA.isString])({}, 1, 'abc') //=> true
 * RA.argsPass(R.any, [RA.isArray, RA.isBoolean, RA.isString])({}, 1, false) //=> false
 * RA.argsPass(R.none, [RA.isArray, RA.isBoolean, RA.isString])({}, 1, false) //=> true
 * RA.argsPass(R.none, [RA.isArray, RA.isBoolean, RA.isString])({}, 1, 'abc') //=> false
 */

/* harmony default export */ var argsPass = (Object(external_ramda_["curry"])(function (combiningPredicate, predicates) {
  return Object(external_ramda_["useWith"])(Object(external_ramda_["compose"])(combiningPredicate(src_isTruthy), src_list), predicates);
}));
// CONCATENATED MODULE: ./src/dropArgs.js

/**
 * Accepts a function with any arity and returns a function with arity of zero.
 * The returned function ignores any arguments supplied to it.
 *
 * @func dropArgs
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.10.0|v2.10.0}
 * @category Logic
 * @sig (...a -> b)-> () -> b
 * @param {Function} fn The function with any arity
 * @return {Function} Returns function with arity of zero
 * @see {@link http://ramdajs.com/docs/#nAry|R.nAry}
 * @example
 *
 * const fn = (a = 1, b = 2) => a + b;
 *
 * RA.dropArgs(fn)('ignore1', 'ignore2'); //=> 3
 */

var dropArgs = Object(external_ramda_["nAry"])(0);
/* harmony default export */ var src_dropArgs = (dropArgs);
// CONCATENATED MODULE: ./src/round.js


/**
 * Returns the value of a number rounded to the nearest integer.
 *
 * @func round
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.15.0|v2.15.0}
 * @category Math
 * @sig Number -> Number
 * @param {number} number The number to round
 * @return {number} The value of the given number rounded to the nearest integer
 * @example
 *
 * RA.round(0.9); //=> 1
 * RA.round(5.95); //=> 6
 * RA.round(5.5); //=> 6
 * RA.round(5.05); //=> 5
 * RA.round(-5.05); //=> -5
 * RA.round(-5.5); //=> -5
 * RA.round(-5.95); //=> -6
 */

var round = _curry1_default()(Object(external_ramda_["bind"])(Math.round, Math));
/* harmony default export */ var src_round = (round);
// CONCATENATED MODULE: ./src/ceil.js


/**
 * Returns the smallest integer greater than or equal to a given number.
 *
 * Note: ceil(null) returns integer 0 and does not give a NaN error.
 *
 * @func ceil
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.15.0|v2.15.0}
 * @category Math
 * @sig Number -> Number
 * @param {number} number The number to ceil
 * @return {number} The smallest integer greater than or equal to the given number
 * @example
 *
 * RA.ceil(.95); //=> 1
 * RA.ceil(4); //=> 4
 * RA.ceil(7.004); //=> 8
 * RA.ceil(-0.95); //=> -0
 * RA.ceil(-4); //=> -4
 * RA.ceil(-7.004); //=> -7
 * RA.ceil(null); //=> 0
 */

var ceil = _curry1_default()(Object(external_ramda_["bind"])(Math.ceil, Math));
/* harmony default export */ var src_ceil = (ceil);
// CONCATENATED MODULE: ./src/floor.js


/**
 * Returns the largest integer less than or equal to a given number.
 *
 * Note: floor(null) returns integer 0 and do not give a NaN error.
 *
 * @func floor
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.15.0|v2.15.0}
 * @category Math
 * @sig Number -> Number
 * @param {number} number The number to floor
 * @return {number} A number representing the largest integer less than or equal to the specified number
 * @example
 *
 * RA.floor(45.95); //=> 45
 * RA.floor(45.05); //=> 45
 * RA.floor(4); //=> 4
 * RA.floor(-45.05); //=> -46
 * RA.floor(-45.95); //=> -46
 * RA.floor(null); //=> 0
 */

var floor = _curry1_default()(Object(external_ramda_["bind"])(Math.floor, Math));
/* harmony default export */ var src_floor = (floor);
// CONCATENATED MODULE: ./src/internal/polyfills/Math.trunc.js


var Math_trunc_truncPolyfill = function truncPolyfill(v) {
  var numV = Number(v);

  if (!src_isFinite(numV)) {
    return numV;
  } // eslint-disable-next-line no-nested-ternary


  return numV - numV % 1 || (numV < 0 ? -0 : numV === 0 ? numV : 0);
};

/* harmony default export */ var Math_trunc = (Math_trunc_truncPolyfill);
// CONCATENATED MODULE: ./src/trunc.js




var trunc_truncPolyfill = _curry1_default()(Math_trunc);
/**
 * Returns the integer part of a number by removing any fractional digits.
 *
 * @func trunc
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.15.0|v2.15.0}
 * @category Math
 * @sig Number | String -> Number
 * @param {number|string} number The number to trunc
 * @return {number} The integer part of the given number
 * @example
 *
 * RA.trunc(13.37); //=> 13
 * RA.trunc(42.84); //=> 42
 * RA.trunc(0.123); //=>  0
 * RA.trunc(-0.123); //=> -0
 * RA.trunc('-1.123'); //=> -1
 * RA.trunc(NaN); //=> NaN
 * RA.trunc('foo'); //=> NaN
 */

var trunc = src_isFunction(Math.trunc) ? _curry1_default()(Object(external_ramda_["bind"])(Math.trunc, Math)) : trunc_truncPolyfill;
/* harmony default export */ var src_trunc = (trunc);
// CONCATENATED MODULE: ./src/internal/polyfills/Math.sign.js
var signPolyfill = function signPolyfill(number) {
  return (number > 0) - (number < 0) || +number;
};

/* harmony default export */ var Math_sign = (signPolyfill);
// CONCATENATED MODULE: ./src/sign.js




var sign_signPolyfill = _curry1_default()(Math_sign);
/**
 * Returns the sign of a number, indicating whether the number is positive, negative or zero.
 *
 * @func sign
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.15.0|v2.15.0}
 * @category Math
 * @sig Number | String -> Number
 * @param {number} number A number
 * @return {number} A number representing the sign of the given argument. If the argument is a positive number, negative number, positive zero or negative zero, the function will return 1, -1, 0 or -0 respectively. Otherwise, NaN is returned
 * @example
 *
 * RA.sign(3); //  1
 * RA.sign(-3); // -1
 * RA.sign('-3'); // -1
 * RA.sign(0); //  0
 * RA.sign(-0); // -0
 * RA.sign(NaN); // NaN
 * RA.sign('foo'); // NaN
 */

var sign = src_isFunction(Math.sign) ? _curry1_default()(Object(external_ramda_["bind"])(Math.sign, Math)) : sign_signPolyfill;
/* harmony default export */ var src_sign = (sign);
// CONCATENATED MODULE: ./src/replaceAll.js


/**
 * Replaces all substring matches in a string with a replacement.
 *
 * @func replaceAll
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.17.0|v2.17.0}
 * @category String
 * @sig String -> String -> String -> String
 * @param {string} searchValue The substring to match
 * @param {string} replaceValue The string to replace the matches with
 * @param {string} str The String to do the search and replacement in
 * @return {string} A new string containing all the `searchValue` replaced with the `replaceValue`
 * @throws {Error} When `searchValue` is RegExp
 * @see {@link http://ramdajs.com/docs/#replace|R.replace}, {@link https://github.com/tc39/proposal-string-replaceall|TC39 proposal}
 * @example
 *
 * RA.replaceAll('ac', 'ef', 'ac ab ac ab'); //=> 'ef ab ef ab'
 */

var replaceAll = Object(external_ramda_["curryN"])(3, function (searchValue, replaceValue, str) {
  if (src_isRegExp(searchValue)) {
    throw new Error('searchValue must be a String, not a RegExp.');
  }

  return Object(external_ramda_["pipe"])(Object(external_ramda_["split"])(String(searchValue)), Object(external_ramda_["join"])(String(replaceValue)))(str);
});
/* harmony default export */ var src_replaceAll = (replaceAll);
// CONCATENATED MODULE: ./src/index.js
/* concated harmony reexport isNotUndefined */__webpack_require__.d(__webpack_exports__, "isNotUndefined", function() { return src_isNotUndefined; });
/* concated harmony reexport isUndefined */__webpack_require__.d(__webpack_exports__, "isUndefined", function() { return src_isUndefined; });
/* concated harmony reexport isNull */__webpack_require__.d(__webpack_exports__, "isNull", function() { return src_isNull; });
/* concated harmony reexport isNotNull */__webpack_require__.d(__webpack_exports__, "isNotNull", function() { return src_isNotNull; });
/* concated harmony reexport isNotNil */__webpack_require__.d(__webpack_exports__, "isNotNil", function() { return src_isNotNil; });
/* concated harmony reexport isArray */__webpack_require__.d(__webpack_exports__, "isArray", function() { return src_isArray; });
/* concated harmony reexport isIterable */__webpack_require__.d(__webpack_exports__, "isIterable", function() { return src_isIterable; });
/* concated harmony reexport isEmptyArray */__webpack_require__.d(__webpack_exports__, "isEmptyArray", function() { return src_isEmptyArray; });
/* concated harmony reexport isNotArray */__webpack_require__.d(__webpack_exports__, "isNotArray", function() { return src_isNotArray; });
/* concated harmony reexport isNonEmptyArray */__webpack_require__.d(__webpack_exports__, "isNonEmptyArray", function() { return src_isNonEmptyArray; });
/* concated harmony reexport isBoolean */__webpack_require__.d(__webpack_exports__, "isBoolean", function() { return src_isBoolean; });
/* concated harmony reexport isNotBoolean */__webpack_require__.d(__webpack_exports__, "isNotBoolean", function() { return src_isNotBoolean; });
/* concated harmony reexport isNilOrEmpty */__webpack_require__.d(__webpack_exports__, "isNilOrEmpty", function() { return src_isNilOrEmpty; });
/* concated harmony reexport isString */__webpack_require__.d(__webpack_exports__, "isString", function() { return src_isString; });
/* concated harmony reexport isEmptyString */__webpack_require__.d(__webpack_exports__, "isEmptyString", function() { return src_isEmptyString; });
/* concated harmony reexport isNotString */__webpack_require__.d(__webpack_exports__, "isNotString", function() { return src_isNotString; });
/* concated harmony reexport isNonEmptyString */__webpack_require__.d(__webpack_exports__, "isNonEmptyString", function() { return src_isNonEmptyString; });
/* concated harmony reexport isArrayLike */__webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return src_isArrayLike; });
/* concated harmony reexport isNotArrayLike */__webpack_require__.d(__webpack_exports__, "isNotArrayLike", function() { return src_isNotArrayLike; });
/* concated harmony reexport isGeneratorFunction */__webpack_require__.d(__webpack_exports__, "isGeneratorFunction", function() { return src_isGeneratorFunction; });
/* concated harmony reexport isNotGeneratorFunction */__webpack_require__.d(__webpack_exports__, "isNotGeneratorFunction", function() { return src_isNotGeneratorFunction; });
/* concated harmony reexport isAsyncFunction */__webpack_require__.d(__webpack_exports__, "isAsyncFunction", function() { return src_isAsyncFunction; });
/* concated harmony reexport isNotAsyncFunction */__webpack_require__.d(__webpack_exports__, "isNotAsyncFunction", function() { return src_isNotAsyncFunction; });
/* concated harmony reexport isFunction */__webpack_require__.d(__webpack_exports__, "isFunction", function() { return src_isFunction; });
/* concated harmony reexport isNotFunction */__webpack_require__.d(__webpack_exports__, "isNotFunction", function() { return src_isNotFunction; });
/* concated harmony reexport isObj */__webpack_require__.d(__webpack_exports__, "isObj", function() { return src_isObj; });
/* concated harmony reexport isObject */__webpack_require__.d(__webpack_exports__, "isObject", function() { return src_isObj; });
/* concated harmony reexport isNotObj */__webpack_require__.d(__webpack_exports__, "isNotObj", function() { return src_isNotObj; });
/* concated harmony reexport isNotObject */__webpack_require__.d(__webpack_exports__, "isNotObject", function() { return src_isNotObj; });
/* concated harmony reexport isObjLike */__webpack_require__.d(__webpack_exports__, "isObjLike", function() { return src_isObjLike; });
/* concated harmony reexport isObjectLike */__webpack_require__.d(__webpack_exports__, "isObjectLike", function() { return src_isObjLike; });
/* concated harmony reexport isNotObjLike */__webpack_require__.d(__webpack_exports__, "isNotObjLike", function() { return src_isNotObjLike; });
/* concated harmony reexport isNotObjectLike */__webpack_require__.d(__webpack_exports__, "isNotObjectLike", function() { return src_isNotObjLike; });
/* concated harmony reexport isPlainObj */__webpack_require__.d(__webpack_exports__, "isPlainObj", function() { return src_isPlainObj; });
/* concated harmony reexport isPlainObject */__webpack_require__.d(__webpack_exports__, "isPlainObject", function() { return src_isPlainObj; });
/* concated harmony reexport isNotPlainObj */__webpack_require__.d(__webpack_exports__, "isNotPlainObj", function() { return src_isNotPlainObj; });
/* concated harmony reexport isNotPlainObject */__webpack_require__.d(__webpack_exports__, "isNotPlainObject", function() { return src_isNotPlainObj; });
/* concated harmony reexport isDate */__webpack_require__.d(__webpack_exports__, "isDate", function() { return src_isDate; });
/* concated harmony reexport isNotDate */__webpack_require__.d(__webpack_exports__, "isNotDate", function() { return src_isNotDate; });
/* concated harmony reexport isValidDate */__webpack_require__.d(__webpack_exports__, "isValidDate", function() { return src_isValidDate; });
/* concated harmony reexport isNotValidDate */__webpack_require__.d(__webpack_exports__, "isNotValidDate", function() { return src_isNotValidDate; });
/* concated harmony reexport isInvalidDate */__webpack_require__.d(__webpack_exports__, "isInvalidDate", function() { return src_isNotValidDate; });
/* concated harmony reexport isNumber */__webpack_require__.d(__webpack_exports__, "isNumber", function() { return src_isNumber; });
/* concated harmony reexport isNotNumber */__webpack_require__.d(__webpack_exports__, "isNotNumber", function() { return src_isNotNumber; });
/* concated harmony reexport isPositive */__webpack_require__.d(__webpack_exports__, "isPositive", function() { return src_isPositive; });
/* concated harmony reexport isNegative */__webpack_require__.d(__webpack_exports__, "isNegative", function() { return src_isNegative; });
/* concated harmony reexport isNotNilOrEmpty */__webpack_require__.d(__webpack_exports__, "isNotNilOrEmpty", function() { return src_isNotNilOrEmpty; });
/* concated harmony reexport isNonPositive */__webpack_require__.d(__webpack_exports__, "isNonPositive", function() { return src_isNonPositive; });
/* concated harmony reexport isNonNegative */__webpack_require__.d(__webpack_exports__, "isNonNegative", function() { return src_isNonNegative; });
/* concated harmony reexport isNaN */__webpack_require__.d(__webpack_exports__, "isNaN", function() { return src_isNaN; });
/* concated harmony reexport isNotNaN */__webpack_require__.d(__webpack_exports__, "isNotNaN", function() { return src_isNotNaN; });
/* concated harmony reexport isFinite */__webpack_require__.d(__webpack_exports__, "isFinite", function() { return src_isFinite; });
/* concated harmony reexport isNotFinite */__webpack_require__.d(__webpack_exports__, "isNotFinite", function() { return src_isNotFinite; });
/* concated harmony reexport isInteger */__webpack_require__.d(__webpack_exports__, "isInteger", function() { return src_isInteger; });
/* concated harmony reexport isNotInteger */__webpack_require__.d(__webpack_exports__, "isNotInteger", function() { return src_isNotInteger; });
/* concated harmony reexport isFloat */__webpack_require__.d(__webpack_exports__, "isFloat", function() { return src_isFloat; });
/* concated harmony reexport isNotFloat */__webpack_require__.d(__webpack_exports__, "isNotFloat", function() { return src_isNotFloat; });
/* concated harmony reexport isValidNumber */__webpack_require__.d(__webpack_exports__, "isValidNumber", function() { return src_isValidNumber; });
/* concated harmony reexport isNotValidNumber */__webpack_require__.d(__webpack_exports__, "isNotValidNumber", function() { return src_isNotValidNumber; });
/* concated harmony reexport isOdd */__webpack_require__.d(__webpack_exports__, "isOdd", function() { return src_isOdd; });
/* concated harmony reexport isEven */__webpack_require__.d(__webpack_exports__, "isEven", function() { return src_isEven; });
/* concated harmony reexport isPair */__webpack_require__.d(__webpack_exports__, "isPair", function() { return src_isPair; });
/* concated harmony reexport isNotPair */__webpack_require__.d(__webpack_exports__, "isNotPair", function() { return src_isNotPair; });
/* concated harmony reexport isThenable */__webpack_require__.d(__webpack_exports__, "isThenable", function() { return src_isThenable; });
/* concated harmony reexport isPromise */__webpack_require__.d(__webpack_exports__, "isPromise", function() { return src_isPromise; });
/* concated harmony reexport isTrue */__webpack_require__.d(__webpack_exports__, "isTrue", function() { return src_isTrue; });
/* concated harmony reexport isFalse */__webpack_require__.d(__webpack_exports__, "isFalse", function() { return src_isFalse; });
/* concated harmony reexport isTruthy */__webpack_require__.d(__webpack_exports__, "isTruthy", function() { return src_isTruthy; });
/* concated harmony reexport isFalsy */__webpack_require__.d(__webpack_exports__, "isFalsy", function() { return src_isFalsy; });
/* concated harmony reexport isRegExp */__webpack_require__.d(__webpack_exports__, "isRegExp", function() { return src_isRegExp; });
/* concated harmony reexport isNotRegExp */__webpack_require__.d(__webpack_exports__, "isNotRegExp", function() { return src_isNotRegExp; });
/* concated harmony reexport stubUndefined */__webpack_require__.d(__webpack_exports__, "stubUndefined", function() { return src_stubUndefined; });
/* concated harmony reexport stubNull */__webpack_require__.d(__webpack_exports__, "stubNull", function() { return src_stubNull; });
/* concated harmony reexport stubObj */__webpack_require__.d(__webpack_exports__, "stubObj", function() { return src_stubObj; });
/* concated harmony reexport stubObject */__webpack_require__.d(__webpack_exports__, "stubObject", function() { return src_stubObj; });
/* concated harmony reexport stubString */__webpack_require__.d(__webpack_exports__, "stubString", function() { return src_stubString; });
/* concated harmony reexport stubArray */__webpack_require__.d(__webpack_exports__, "stubArray", function() { return src_stubArray; });
/* concated harmony reexport noop */__webpack_require__.d(__webpack_exports__, "noop", function() { return src_noop; });
/* concated harmony reexport liftFN */__webpack_require__.d(__webpack_exports__, "liftFN", function() { return src_liftFN; });
/* concated harmony reexport liftF */__webpack_require__.d(__webpack_exports__, "liftF", function() { return src_liftF; });
/* concated harmony reexport cata */__webpack_require__.d(__webpack_exports__, "cata", function() { return cata; });
/* concated harmony reexport weave */__webpack_require__.d(__webpack_exports__, "weave", function() { return src_weave; });
/* concated harmony reexport weaveLazy */__webpack_require__.d(__webpack_exports__, "weaveLazy", function() { return src_weaveLazy; });
/* concated harmony reexport curryRightN */__webpack_require__.d(__webpack_exports__, "curryRightN", function() { return src_curryRightN; });
/* concated harmony reexport curryRight */__webpack_require__.d(__webpack_exports__, "curryRight", function() { return src_curryRight; });
/* concated harmony reexport allP */__webpack_require__.d(__webpack_exports__, "allP", function() { return src_allP; });
/* concated harmony reexport resolveP */__webpack_require__.d(__webpack_exports__, "resolveP", function() { return src_resolveP; });
/* concated harmony reexport rejectP */__webpack_require__.d(__webpack_exports__, "rejectP", function() { return src_rejectP; });
/* concated harmony reexport thenP */__webpack_require__.d(__webpack_exports__, "thenP", function() { return src_thenP; });
/* concated harmony reexport then */__webpack_require__.d(__webpack_exports__, "then", function() { return src_thenP; });
/* concated harmony reexport allSettledP */__webpack_require__.d(__webpack_exports__, "allSettledP", function() { return src_allSettledP; });
/* concated harmony reexport Y */__webpack_require__.d(__webpack_exports__, "Y", function() { return src_Y; });
/* concated harmony reexport seq */__webpack_require__.d(__webpack_exports__, "seq", function() { return src_seq; });
/* concated harmony reexport sequencing */__webpack_require__.d(__webpack_exports__, "sequencing", function() { return src_seq; });
/* concated harmony reexport dispatch */__webpack_require__.d(__webpack_exports__, "dispatch", function() { return src_dispatch; });
/* concated harmony reexport async */__webpack_require__.d(__webpack_exports__, "async", function() { return src_async; });
/* concated harmony reexport mapIndexed */__webpack_require__.d(__webpack_exports__, "mapIndexed", function() { return src_mapIndexed; });
/* concated harmony reexport reduceIndexed */__webpack_require__.d(__webpack_exports__, "reduceIndexed", function() { return src_reduceIndexed; });
/* concated harmony reexport pickIndexes */__webpack_require__.d(__webpack_exports__, "pickIndexes", function() { return src_pickIndexes; });
/* concated harmony reexport list */__webpack_require__.d(__webpack_exports__, "list", function() { return src_list; });
/* concated harmony reexport ensureArray */__webpack_require__.d(__webpack_exports__, "ensureArray", function() { return src_ensureArray; });
/* concated harmony reexport concatAll */__webpack_require__.d(__webpack_exports__, "concatAll", function() { return src_concatAll; });
/* concated harmony reexport concatRight */__webpack_require__.d(__webpack_exports__, "concatRight", function() { return src_concatRight; });
/* concated harmony reexport reduceP */__webpack_require__.d(__webpack_exports__, "reduceP", function() { return src_reduceP; });
/* concated harmony reexport reduceRightP */__webpack_require__.d(__webpack_exports__, "reduceRightP", function() { return src_reduceRightP; });
/* concated harmony reexport sliceFrom */__webpack_require__.d(__webpack_exports__, "sliceFrom", function() { return src_sliceFrom; });
/* concated harmony reexport sliceTo */__webpack_require__.d(__webpack_exports__, "sliceTo", function() { return src_sliceTo; });
/* concated harmony reexport omitIndexes */__webpack_require__.d(__webpack_exports__, "omitIndexes", function() { return src_omitIndexes; });
/* concated harmony reexport compact */__webpack_require__.d(__webpack_exports__, "compact", function() { return src_compact; });
/* concated harmony reexport appendFlipped */__webpack_require__.d(__webpack_exports__, "appendFlipped", function() { return src_appendFlipped; });
/* concated harmony reexport contained */__webpack_require__.d(__webpack_exports__, "contained", function() { return src_contained; });
/* concated harmony reexport included */__webpack_require__.d(__webpack_exports__, "included", function() { return src_contained; });
/* concated harmony reexport move */__webpack_require__.d(__webpack_exports__, "move", function() { return src_move; });
/* concated harmony reexport lengthGt */__webpack_require__.d(__webpack_exports__, "lengthGt", function() { return src_lengthGt; });
/* concated harmony reexport lengthLt */__webpack_require__.d(__webpack_exports__, "lengthLt", function() { return src_lengthLt; });
/* concated harmony reexport lengthGte */__webpack_require__.d(__webpack_exports__, "lengthGte", function() { return src_lengthGte; });
/* concated harmony reexport lengthLte */__webpack_require__.d(__webpack_exports__, "lengthLte", function() { return src_lengthLte; });
/* concated harmony reexport lengthEq */__webpack_require__.d(__webpack_exports__, "lengthEq", function() { return src_lengthEq; });
/* concated harmony reexport lengthNotEq */__webpack_require__.d(__webpack_exports__, "lengthNotEq", function() { return src_lengthNotEq; });
/* concated harmony reexport allEqual */__webpack_require__.d(__webpack_exports__, "allEqual", function() { return src_allEqual; });
/* concated harmony reexport repeatStr */__webpack_require__.d(__webpack_exports__, "repeatStr", function() { return src_repeatStr; });
/* concated harmony reexport allIdentical */__webpack_require__.d(__webpack_exports__, "allIdentical", function() { return src_allIdentical; });
/* concated harmony reexport allIdenticalTo */__webpack_require__.d(__webpack_exports__, "allIdenticalTo", function() { return src_allIdenticalTo; });
/* concated harmony reexport allEqualTo */__webpack_require__.d(__webpack_exports__, "allEqualTo", function() { return src_allEqualTo; });
/* concated harmony reexport paths */__webpack_require__.d(__webpack_exports__, "paths", function() { return src_paths; });
/* concated harmony reexport renameKeys */__webpack_require__.d(__webpack_exports__, "renameKeys", function() { return src_renameKeys; });
/* concated harmony reexport renameKeysWith */__webpack_require__.d(__webpack_exports__, "renameKeysWith", function() { return src_renameKeysWith; });
/* concated harmony reexport mergeRight */__webpack_require__.d(__webpack_exports__, "mergeRight", function() { return src_mergeRight; });
/* concated harmony reexport mergeLeft */__webpack_require__.d(__webpack_exports__, "mergeLeft", function() { return src_mergeRight; });
/* concated harmony reexport resetToDefault */__webpack_require__.d(__webpack_exports__, "resetToDefault", function() { return src_mergeRight; });
/* concated harmony reexport mergeProps */__webpack_require__.d(__webpack_exports__, "mergeProps", function() { return src_mergeProps; });
/* concated harmony reexport mergePaths */__webpack_require__.d(__webpack_exports__, "mergePaths", function() { return src_mergePaths; });
/* concated harmony reexport mergeProp */__webpack_require__.d(__webpack_exports__, "mergeProp", function() { return src_mergeProp; });
/* concated harmony reexport mergePath */__webpack_require__.d(__webpack_exports__, "mergePath", function() { return src_mergePath; });
/* concated harmony reexport omitBy */__webpack_require__.d(__webpack_exports__, "omitBy", function() { return src_omitBy; });
/* concated harmony reexport viewOr */__webpack_require__.d(__webpack_exports__, "viewOr", function() { return src_viewOr; });
/* concated harmony reexport hasPath */__webpack_require__.d(__webpack_exports__, "hasPath", function() { return src_hasPath; });
/* concated harmony reexport spreadProp */__webpack_require__.d(__webpack_exports__, "spreadProp", function() { return src_spreadProp; });
/* concated harmony reexport spreadPath */__webpack_require__.d(__webpack_exports__, "spreadPath", function() { return src_spreadPath; });
/* concated harmony reexport flattenProp */__webpack_require__.d(__webpack_exports__, "flattenProp", function() { return src_flattenProp; });
/* concated harmony reexport flattenPath */__webpack_require__.d(__webpack_exports__, "flattenPath", function() { return src_flattenPath; });
/* concated harmony reexport lensEq */__webpack_require__.d(__webpack_exports__, "lensEq", function() { return src_lensEq; });
/* concated harmony reexport lensNotEq */__webpack_require__.d(__webpack_exports__, "lensNotEq", function() { return src_lensNotEq; });
/* concated harmony reexport lensSatisfies */__webpack_require__.d(__webpack_exports__, "lensSatisfies", function() { return src_lensSatisfies; });
/* concated harmony reexport lensNotSatisfy */__webpack_require__.d(__webpack_exports__, "lensNotSatisfy", function() { return src_lensNotSatisfy; });
/* concated harmony reexport lensTraverse */__webpack_require__.d(__webpack_exports__, "lensTraverse", function() { return src_lensTraverse; });
/* concated harmony reexport lensIso */__webpack_require__.d(__webpack_exports__, "lensIso", function() { return src_lensIso; });
/* concated harmony reexport propNotEq */__webpack_require__.d(__webpack_exports__, "propNotEq", function() { return src_propNotEq; });
/* concated harmony reexport pathNotEq */__webpack_require__.d(__webpack_exports__, "pathNotEq", function() { return src_pathNotEq; });
/* concated harmony reexport inRange */__webpack_require__.d(__webpack_exports__, "inRange", function() { return inRange; });
/* concated harmony reexport isNotEmpty */__webpack_require__.d(__webpack_exports__, "isNotEmpty", function() { return src_isNotEmpty; });
/* concated harmony reexport defaultWhen */__webpack_require__.d(__webpack_exports__, "defaultWhen", function() { return src_defaultWhen; });
/* concated harmony reexport notBoth */__webpack_require__.d(__webpack_exports__, "notBoth", function() { return src_notBoth; });
/* concated harmony reexport neither */__webpack_require__.d(__webpack_exports__, "neither", function() { return src_neither; });
/* concated harmony reexport notAllPass */__webpack_require__.d(__webpack_exports__, "notAllPass", function() { return src_notAllPass; });
/* concated harmony reexport nonePass */__webpack_require__.d(__webpack_exports__, "nonePass", function() { return src_nonePass; });
/* concated harmony reexport argsPass */__webpack_require__.d(__webpack_exports__, "argsPass", function() { return argsPass; });
/* concated harmony reexport dropArgs */__webpack_require__.d(__webpack_exports__, "dropArgs", function() { return src_dropArgs; });
/* concated harmony reexport round */__webpack_require__.d(__webpack_exports__, "round", function() { return src_round; });
/* concated harmony reexport ceil */__webpack_require__.d(__webpack_exports__, "ceil", function() { return src_ceil; });
/* concated harmony reexport floor */__webpack_require__.d(__webpack_exports__, "floor", function() { return src_floor; });
/* concated harmony reexport trunc */__webpack_require__.d(__webpack_exports__, "trunc", function() { return src_trunc; });
/* concated harmony reexport sign */__webpack_require__.d(__webpack_exports__, "sign", function() { return src_sign; });
/* concated harmony reexport replaceAll */__webpack_require__.d(__webpack_exports__, "replaceAll", function() { return src_replaceAll; });
/* concated harmony reexport Identity */__webpack_require__.d(__webpack_exports__, "Identity", function() { return fantasy_land_Identity; });
/**
 * @namespace RA
 */
// Type


























 // alias of isObject


 // alias of isNotObj


 // alias of isObjLike


 // alias of isNotObjLike




 // alias of isNotPlainObject





 // alias of isNotValidDate





























 // Function

























 // List




























 // Object

















 // Relation









 // Logic








 // Math





 // String

 // Types



/***/ })
/******/ ]);
});